<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE WIDTH="100%" CLASS="hdft" CELLSPACING="0"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Fri Jun 05 14:15:56 PDT 2015)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="24.html">org.apache.pdfbox.util</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">PDFTextStripper.java</SPAN>]</H2><TABLE WIDTH="100%" CELLSPACING="0"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>PDFTextStripper.java</TD><TD CLASS="h">67%  (2/3)</TD><TD CLASS="h">64%  (62/97)</TD><TD CLASS="h">66%  (1476/2233)</TD><TD CLASS="h">68%  (370.7/543)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE WIDTH="100%" CLASS="cn" CELLSPACING="0"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">PDFTextStripper$WordSeparator</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#0">&lt;static initializer&gt;</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">PDFTextStripper$WordSeparator (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#3">getSeparator (): PDFTextStripper$WordSeparator</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#4">PDFTextStripper</A></TD><TD>100% (1/1)</TD><TD CLASS="h">65%  (59/91)</TD><TD CLASS="h">66%  (1461/2208)</TD><TD CLASS="h">68%  (364.7/533)</TD></TR><TR><TD CLASS="f"><A HREF="#5">PDFTextStripper (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/114)</TD><TD CLASS="h">0%   (0/34)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">PDFTextStripper (Properties): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/112)</TD><TD CLASS="h">0%   (0/34)</TD></TR><TR><TD CLASS="f"><A HREF="#7">getCharactersByArticle (): Vector</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">getCurrentPageNo (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#9">getEndBookmark (): PDOutlineItem</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">getEndPage (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#b">getOutput (): Writer</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">getPageNumber (PDOutlineItem, List): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/17)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#d">getPageSeparator (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">getSeparateByBeads (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#f">getStartBookmark (): PDOutlineItem</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">getStartPage (): int</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#11">getSuppressDuplicateOverlappingText (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">getText (COSDocument): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/7)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#13">getWordSeparator (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#14">inspectFontEncoding (String): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/51)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#15">setAddMoreFormatting (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">setAverageCharTolerance (float): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#17">setDropThreshold (float): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">setEndBookmark (PDOutlineItem): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#19">setIndentThreshold (float): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">setListItemPatterns (List): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">setPageSeparator (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">setSpacingTolerance (float): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">setStartBookmark (PDOutlineItem): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1e">setSuppressDuplicateOverlappingText (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#1f">setWordSeparator (String): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#20">startArticle (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#21">writeCharacters (TextPosition): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#22">writePageSeperator (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/9)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#23">writeText (COSDocument, Writer): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#24">writeWordSeparator (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#25">normalizeAdd (LinkedList, StringBuilder, List, TextPosition): StringBuilder</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">44%  (14/32)</TD><TD CLASS="h">57%  (4/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#26">processPages (List): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">56%  (43/77)</TD><TD CLASS="h">68%  (12.3/18)</TD></TR><TR><TD CLASS="f"><A HREF="#27">processTextPosition (TextPosition): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">61%  (189/311)</TD><TD CLASS="h">65%  (47.8/74)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#28">writeText (PDDocument, Writer): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">62%  (26/42)</TD><TD CLASS="h">67%  (8/12)</TD></TR><TR><TD CLASS="f"><A HREF="#29">normalize (List, boolean, boolean): List</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">67%  (45/67)</TD><TD CLASS="h">71%  (10/14)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2a">writeParagraphStart (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>71%  (12/17)</TD><TD CLASS="h">67%  (4/6)</TD></TR><TR><TD CLASS="f"><A HREF="#2b">overlap (float, float, float, float): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>80%  (24/30)</TD><TD>80%  (0.8/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2c">processPage (PDPage, COSStream): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>80%  (77/96)</TD><TD>86%  (14.6/17)</TD></TR><TR><TD CLASS="f"><A HREF="#2d">isParagraphSeparation (PositionWrapper, PositionWrapper, PositionWrapper, flo...</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>81%  (91/112)</TD><TD CLASS="h">77%  (24/31)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">&lt;static initializer&gt;</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>82%  (116/141)</TD><TD CLASS="h">61%  (17.7/29)</TD></TR><TR><TD CLASS="f"><A HREF="#2f">writeParagraphEnd (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>86%  (12/14)</TD><TD>80%  (4/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#30">handleLineSeparation (PositionWrapper, PositionWrapper, PositionWrapper, floa...</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>89%  (25/28)</TD><TD>90%  (9/10)</TD></TR><TR><TD CLASS="f"><A HREF="#31">writePage (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>91%  (376/415)</TD><TD>90%  (102.6/114)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#32">matchPattern (String, List): Pattern</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>91%  (20/22)</TD><TD>83%  (5/6)</TD></TR><TR><TD CLASS="f"><A HREF="#33">writeLine (List, boolean): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>93%  (27/29)</TD><TD>86%  (6/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#34">PDFTextStripper (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (114/114)</TD><TD>100% (34/34)</TD></TR><TR><TD CLASS="f"><A HREF="#35">createWord (String, List): PDFTextStripper$WordWithTextPositions</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (9/9)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#36">endArticle (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#37">endDocument (PDDocument): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (1/1)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#38">endPage (PDPage): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (1/1)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#39">getAddMoreFormatting (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3a">getArticleEnd (): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3b">getArticleStart (): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3c">getAverageCharTolerance (): float</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3d">getDropThreshold (): float</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#3e">getIndentThreshold (): float</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#3f">getLineSeparator (): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#40">getListItemPatterns (): List</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (35/35)</TD><TD>100% (6/6)</TD></TR><TR><TD CLASS="f"><A HREF="#41">getPageEnd (): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#42">getPageStart (): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#43">getParagraphEnd (): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#44">getParagraphStart (): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#45">getSortByPosition (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#46">getSpacingTolerance (): float</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#47">getText (PDDocument): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#48">matchListItemPattern (PositionWrapper): Pattern</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#49">multiplyFloat (float, float): float</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (10/10)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4a">resetEngine (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (27/27)</TD><TD>100% (10/10)</TD></TR><TR><TD CLASS="f"><A HREF="#4b">setArticleEnd (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4c">setArticleStart (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#4d">setEndPage (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4e">setLineSeparator (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#4f">setPageEnd (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#50">setPageStart (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#51">setParagraphEnd (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#52">setParagraphStart (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#53">setShouldSeparateByBeads (boolean): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#54">setSortByPosition (boolean): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#55">setStartPage (int): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#56">startArticle (boolean): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#57">startDocument (PDDocument): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (1/1)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#58">startPage (PDPage): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (1/1)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#59">within (float, float, float): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (16/16)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5a">writeLineSeparator (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#5b">writePageEnd (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5c">writePageStart (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (6/6)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#5d">writeParagraphSeparator (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5e">writeString (String): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="f"><A HREF="#5f">writeString (String, List): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#60">PDFTextStripper$WordWithTextPositions</A></TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (15/15)</TD><TD>100% (6/6)</TD></TR><TR><TD CLASS="f"><A HREF="#60">PDFTextStripper$WordWithTextPositions (String, List): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (9/9)</TD><TD>100% (4/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#62">getText (): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#63">getTextPositions (): List</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR></TABLE><P></P><TABLE WIDTH="100%" CLASS="s" CELLSPACING="0"><TR><TD CLASS="l">1</TD><TD>/*</TD></TR><TR><TD CLASS="l">2</TD><TD> * Licensed to the Apache Software Foundation (ASF) under one or more</TD></TR><TR><TD CLASS="l">3</TD><TD> * contributor license agreements.  See the NOTICE file distributed with</TD></TR><TR><TD CLASS="l">4</TD><TD> * this work for additional information regarding copyright ownership.</TD></TR><TR><TD CLASS="l">5</TD><TD> * The ASF licenses this file to You under the Apache License, Version 2.0</TD></TR><TR><TD CLASS="l">6</TD><TD> * (the &#34;License&#34;); you may not use this file except in compliance with</TD></TR><TR><TD CLASS="l">7</TD><TD> * the License.  You may obtain a copy of the License at</TD></TR><TR><TD CLASS="l">8</TD><TD> *</TD></TR><TR><TD CLASS="l">9</TD><TD> *      http://www.apache.org/licenses/LICENSE-2.0</TD></TR><TR><TD CLASS="l">10</TD><TD> *</TD></TR><TR><TD CLASS="l">11</TD><TD> * Unless required by applicable law or agreed to in writing, software</TD></TR><TR><TD CLASS="l">12</TD><TD> * distributed under the License is distributed on an &#34;AS IS&#34; BASIS,</TD></TR><TR><TD CLASS="l">13</TD><TD> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</TD></TR><TR><TD CLASS="l">14</TD><TD> * See the License for the specific language governing permissions and</TD></TR><TR><TD CLASS="l">15</TD><TD> * limitations under the License.</TD></TR><TR><TD CLASS="l">16</TD><TD> */</TD></TR><TR><TD CLASS="l">17</TD><TD>package org.apache.pdfbox.util;</TD></TR><TR><TD CLASS="l">18</TD><TD> </TD></TR><TR><TD CLASS="l">19</TD><TD>import java.io.IOException;</TD></TR><TR><TD CLASS="l">20</TD><TD>import java.io.StringWriter;</TD></TR><TR><TD CLASS="l">21</TD><TD>import java.io.Writer;</TD></TR><TR><TD CLASS="l">22</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">23</TD><TD>import java.util.Collections;</TD></TR><TR><TD CLASS="l">24</TD><TD>import java.util.HashMap;</TD></TR><TR><TD CLASS="l">25</TD><TD>import java.util.Iterator;</TD></TR><TR><TD CLASS="l">26</TD><TD>import java.util.LinkedList;</TD></TR><TR><TD CLASS="l">27</TD><TD>import java.util.List;</TD></TR><TR><TD CLASS="l">28</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">29</TD><TD>import java.util.Properties;</TD></TR><TR><TD CLASS="l">30</TD><TD>import java.util.SortedMap;</TD></TR><TR><TD CLASS="l">31</TD><TD>import java.util.SortedSet;</TD></TR><TR><TD CLASS="l">32</TD><TD>import java.util.TreeMap;</TD></TR><TR><TD CLASS="l">33</TD><TD>import java.util.TreeSet;</TD></TR><TR><TD CLASS="l">34</TD><TD>import java.util.Vector;</TD></TR><TR><TD CLASS="l">35</TD><TD>import java.util.regex.Pattern;</TD></TR><TR><TD CLASS="l">36</TD><TD> </TD></TR><TR><TD CLASS="l">37</TD><TD>import org.apache.pdfbox.cos.COSDocument;</TD></TR><TR><TD CLASS="l">38</TD><TD>import org.apache.pdfbox.cos.COSStream;</TD></TR><TR><TD CLASS="l">39</TD><TD>import org.apache.pdfbox.pdmodel.PDDocument;</TD></TR><TR><TD CLASS="l">40</TD><TD>import org.apache.pdfbox.pdmodel.PDPage;</TD></TR><TR><TD CLASS="l">41</TD><TD>import org.apache.pdfbox.pdmodel.common.COSObjectable;</TD></TR><TR><TD CLASS="l">42</TD><TD>import org.apache.pdfbox.pdmodel.common.PDRectangle;</TD></TR><TR><TD CLASS="l">43</TD><TD>import org.apache.pdfbox.pdmodel.common.PDStream;</TD></TR><TR><TD CLASS="l">44</TD><TD>import org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem;</TD></TR><TR><TD CLASS="l">45</TD><TD>import org.apache.pdfbox.pdmodel.interactive.pagenavigation.PDThreadBead;</TD></TR><TR><TD CLASS="l">46</TD><TD> </TD></TR><TR><TD CLASS="l">47</TD><TD> </TD></TR><TR><TD CLASS="l">48</TD><TD>/**</TD></TR><TR><TD CLASS="l">49</TD><TD> * This class will take a pdf document and strip out all of the text and ignore the</TD></TR><TR><TD CLASS="l">50</TD><TD> * formatting and such.  Please note; it is up to clients of this class to verify that</TD></TR><TR><TD CLASS="l">51</TD><TD> * a specific user has the correct permissions to extract text from the</TD></TR><TR><TD CLASS="l">52</TD><TD> * PDF document.</TD></TR><TR><TD CLASS="l">53</TD><TD> * </TD></TR><TR><TD CLASS="l">54</TD><TD> * The basic flow of this process is that we get a document and use a series of </TD></TR><TR><TD CLASS="l">55</TD><TD> * processXXX() functions that work on smaller and smaller chunks of the page.  </TD></TR><TR><TD CLASS="l">56</TD><TD> * Eventually, we fully process each page and then print it. </TD></TR><TR><TD CLASS="l">57</TD><TD> *</TD></TR><TR><TD CLASS="l">58</TD><TD> * @author &lt;a href=&#34;mailto:ben@benlitchfield.com&#34;&gt;Ben Litchfield&lt;/a&gt;</TD></TR><TR><TD CLASS="l">59</TD><TD> * </TD></TR><TR><TD CLASS="l"><A NAME="4">60</A></TD><TD> */</TD></TR><TR><TD CLASS="l">61</TD><TD>public class PDFTextStripper extends PDFStreamEngine</TD></TR><TR><TD CLASS="l">62</TD><TD>{</TD></TR><TR><TD CLASS="l">63</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">64</TD><TD>    private static final String thisClassName = PDFTextStripper.class.getSimpleName().toLowerCase();</TD></TR><TR><TD CLASS="l">65</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">66</TD><TD>    private static float DEFAULT_INDENT_THRESHOLD = 2.0f;</TD></TR><TR CLASS="c"><TD CLASS="l">67</TD><TD>    private static float DEFAULT_DROP_THRESHOLD = 2.5f;</TD></TR><TR><TD CLASS="l">68</TD><TD> </TD></TR><TR><TD CLASS="l">69</TD><TD>    private static final boolean useCustomQuicksort;</TD></TR><TR><TD CLASS="l">70</TD><TD>    </TD></TR><TR><TD CLASS="l">71</TD><TD>    //enable the ability to set the default indent/drop thresholds</TD></TR><TR><TD CLASS="l">72</TD><TD>    //with -D system properties:</TD></TR><TR><TD CLASS="l">73</TD><TD>    //    pdftextstripper.indent</TD></TR><TR><TD CLASS="l">74</TD><TD>    //    pdftextstripper.drop</TD></TR><TR><TD CLASS="l">75</TD><TD>    static</TD></TR><TR><TD CLASS="l">76</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">77</TD><TD>        String sdrop = null, sindent = null;</TD></TR><TR><TD CLASS="l">78</TD><TD>        try</TD></TR><TR><TD CLASS="l">79</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">80</TD><TD>            String prop = thisClassName + &#34;.indent&#34;;</TD></TR><TR CLASS="c"><TD CLASS="l">81</TD><TD>            sindent = System.getProperty(prop);</TD></TR><TR CLASS="c"><TD CLASS="l">82</TD><TD>            prop = thisClassName + &#34;.drop&#34;;</TD></TR><TR CLASS="c"><TD CLASS="l">83</TD><TD>            sdrop = System.getProperty(prop);</TD></TR><TR><TD CLASS="l">84</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">85</TD><TD>        catch (SecurityException e)</TD></TR><TR><TD CLASS="l">86</TD><TD>        {</TD></TR><TR><TD CLASS="l">87</TD><TD>            // PDFBOX-1946 when run in an applet</TD></TR><TR><TD CLASS="l">88</TD><TD>            // ignore and use default</TD></TR><TR CLASS="c"><TD CLASS="l">89</TD><TD>        }</TD></TR><TR CLASS="p"><TD TITLE="40% line coverage (2 out of 5 instructions)" CLASS="l">90</TD><TD TITLE="40% line coverage (2 out of 5 instructions)">        if (sindent != null &amp;&amp; sindent.length() &gt; 0)</TD></TR><TR><TD CLASS="l">91</TD><TD>        {</TD></TR><TR><TD CLASS="l">92</TD><TD>            try</TD></TR><TR><TD CLASS="l">93</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">94</TD><TD>                float f = Float.parseFloat(sindent);</TD></TR><TR CLASS="z"><TD CLASS="l">95</TD><TD>                DEFAULT_INDENT_THRESHOLD = f;</TD></TR><TR><TD CLASS="l">96</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">97</TD><TD>            catch (NumberFormatException nfe)</TD></TR><TR><TD CLASS="l">98</TD><TD>            {</TD></TR><TR><TD CLASS="l">99</TD><TD>                //ignore and use default</TD></TR><TR CLASS="z"><TD CLASS="l">100</TD><TD>            }</TD></TR><TR><TD CLASS="l">101</TD><TD>        }</TD></TR><TR CLASS="p"><TD TITLE="40% line coverage (2 out of 5 instructions)" CLASS="l">102</TD><TD TITLE="40% line coverage (2 out of 5 instructions)">        if (sdrop != null &amp;&amp; sdrop.length() &gt; 0)</TD></TR><TR><TD CLASS="l">103</TD><TD>        {</TD></TR><TR><TD CLASS="l">104</TD><TD>            try</TD></TR><TR><TD CLASS="l">105</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">106</TD><TD>                float f = Float.parseFloat(sdrop);</TD></TR><TR CLASS="z"><TD CLASS="l">107</TD><TD>                DEFAULT_DROP_THRESHOLD = f;</TD></TR><TR><TD CLASS="l">108</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">109</TD><TD>            catch (NumberFormatException nfe)</TD></TR><TR><TD CLASS="l">110</TD><TD>            {</TD></TR><TR><TD CLASS="l">111</TD><TD>                //ignore and use default</TD></TR><TR CLASS="z"><TD CLASS="l">112</TD><TD>            }</TD></TR><TR><TD CLASS="l">113</TD><TD>        }</TD></TR><TR><TD CLASS="l">114</TD><TD>        </TD></TR><TR><TD CLASS="l">115</TD><TD>        // check if we need to use the custom quicksort algorithm as a </TD></TR><TR><TD CLASS="l">116</TD><TD>        // workaround to the transitivity issue of TextPositionComparator:</TD></TR><TR><TD CLASS="l">117</TD><TD>        // https://issues.apache.org/jira/browse/PDFBOX-1512</TD></TR><TR CLASS="c"><TD CLASS="l">118</TD><TD>        boolean is16orLess = false;</TD></TR><TR><TD CLASS="l">119</TD><TD>        try</TD></TR><TR><TD CLASS="l">120</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">121</TD><TD>            String[] versionComponents = System.getProperty(&#34;java.version&#34;).split(&#34;\\.&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">122</TD><TD>            int javaMajorVersion = Integer.parseInt(versionComponents[0]);</TD></TR><TR CLASS="c"><TD CLASS="l">123</TD><TD>            int javaMinorVersion = Integer.parseInt(versionComponents[1]);</TD></TR><TR CLASS="p"><TD TITLE="93% line coverage (26 out of 28 instructions)" CLASS="l">124</TD><TD TITLE="93% line coverage (26 out of 28 instructions)">            is16orLess = javaMajorVersion == 1 &amp;&amp; javaMinorVersion &lt;= 6;</TD></TR><TR><TD CLASS="l">125</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">126</TD><TD>        catch (SecurityException e)</TD></TR><TR><TD CLASS="l">127</TD><TD>        {</TD></TR><TR><TD CLASS="l">128</TD><TD>            // when run in an applet ignore and use default</TD></TR><TR><TD CLASS="l">129</TD><TD>            // assume 1.7 or higher so that quicksort is used</TD></TR><TR CLASS="c"><TD CLASS="l">130</TD><TD>        }</TD></TR><TR CLASS="p"><TD TITLE="98% line coverage (49 out of 50 instructions)" CLASS="l">131</TD><TD TITLE="98% line coverage (49 out of 50 instructions)">        useCustomQuicksort = !is16orLess;</TD></TR><TR><TD CLASS="l">132</TD><TD>    }</TD></TR><TR><TD CLASS="l">133</TD><TD> </TD></TR><TR><TD CLASS="l">134</TD><TD>    /**</TD></TR><TR><TD CLASS="l">135</TD><TD>     * The platforms line separator.</TD></TR><TR><TD CLASS="l">136</TD><TD>     */</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">137</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    protected final String systemLineSeparator = System.getProperty(&#34;line.separator&#34;); </TD></TR><TR><TD CLASS="l">138</TD><TD> </TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">139</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private String lineSeparator = systemLineSeparator;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">140</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private String pageSeparator = systemLineSeparator;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">141</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private String wordSeparator = &#34; &#34;;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">142</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private String paragraphStart = &#34;&#34;;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">143</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private String paragraphEnd = &#34;&#34;;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">144</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private String pageStart = &#34;&#34;;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">145</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private String pageEnd = pageSeparator;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">146</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private String articleStart = &#34;&#34;;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">147</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private String articleEnd = &#34;&#34;;</TD></TR><TR><TD CLASS="l">148</TD><TD> </TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">149</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private int currentPageNo = 0;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">150</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private int startPage = 1;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">151</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private int endPage = Integer.MAX_VALUE;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">152</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private PDOutlineItem startBookmark = null;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">153</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private int startBookmarkPageNumber = -1;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">154</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private PDOutlineItem endBookmark = null;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">155</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private int endBookmarkPageNumber = -1;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">156</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private boolean suppressDuplicateOverlappingText = true;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">157</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private boolean shouldSeparateByBeads = true;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">158</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private boolean sortByPosition = false;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">159</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private boolean addMoreFormatting = false;</TD></TR><TR><TD CLASS="l">160</TD><TD>    </TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">161</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private float indentThreshold = DEFAULT_INDENT_THRESHOLD;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">162</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private float dropThreshold = DEFAULT_DROP_THRESHOLD;</TD></TR><TR><TD CLASS="l">163</TD><TD> </TD></TR><TR><TD CLASS="l">164</TD><TD>    // We will need to estimate where to add spaces.  </TD></TR><TR><TD CLASS="l">165</TD><TD>    // These are used to help guess. </TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">166</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private float spacingTolerance = .5f;</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">167</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private float averageCharTolerance = .3f;</TD></TR><TR><TD CLASS="l">168</TD><TD> </TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">169</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private List&lt;PDThreadBead&gt; pageArticles = null;</TD></TR><TR><TD CLASS="l">170</TD><TD>    /**</TD></TR><TR><TD CLASS="l">171</TD><TD>     * The charactersByArticle is used to extract text by article divisions.  For example</TD></TR><TR><TD CLASS="l">172</TD><TD>     * a PDF that has two columns like a newspaper, we want to extract the first column and</TD></TR><TR><TD CLASS="l">173</TD><TD>     * then the second column.  In this example the PDF would have 2 beads(or articles), one for</TD></TR><TR><TD CLASS="l">174</TD><TD>     * each column.  The size of the charactersByArticle would be 5, because not all text on the</TD></TR><TR><TD CLASS="l">175</TD><TD>     * screen will fall into one of the articles.  The five divisions are shown below</TD></TR><TR><TD CLASS="l">176</TD><TD>     *</TD></TR><TR><TD CLASS="l">177</TD><TD>     * Text before first article</TD></TR><TR><TD CLASS="l">178</TD><TD>     * first article text</TD></TR><TR><TD CLASS="l">179</TD><TD>     * text between first article and second article</TD></TR><TR><TD CLASS="l">180</TD><TD>     * second article text</TD></TR><TR><TD CLASS="l">181</TD><TD>     * text after second article</TD></TR><TR><TD CLASS="l">182</TD><TD>     *</TD></TR><TR><TD CLASS="l">183</TD><TD>     * Most PDFs won't have any beads, so charactersByArticle will contain a single entry.</TD></TR><TR><TD CLASS="l">184</TD><TD>     */</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">185</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    protected Vector&lt;List&lt;TextPosition&gt;&gt; charactersByArticle = new Vector&lt;List&lt;TextPosition&gt;&gt;();</TD></TR><TR><TD CLASS="l">186</TD><TD> </TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">187</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private Map&lt;String, TreeMap&lt;Float, TreeSet&lt;Float&gt;&gt;&gt; characterListMapping =</TD></TR><TR><TD CLASS="l">188</TD><TD>        new HashMap&lt;String, TreeMap&lt;Float, TreeSet&lt;Float&gt;&gt;&gt;();</TD></TR><TR><TD CLASS="l">189</TD><TD> </TD></TR><TR><TD CLASS="l">190</TD><TD>    /**</TD></TR><TR><TD CLASS="l">191</TD><TD>     * encoding that text will be written in (or null).</TD></TR><TR><TD CLASS="l">192</TD><TD>     */</TD></TR><TR><TD CLASS="l">193</TD><TD>    protected String outputEncoding; </TD></TR><TR><TD CLASS="l">194</TD><TD> </TD></TR><TR><TD CLASS="l">195</TD><TD>    /**</TD></TR><TR><TD CLASS="l">196</TD><TD>     * The document to read.</TD></TR><TR><TD CLASS="l">197</TD><TD>     */</TD></TR><TR><TD CLASS="l">198</TD><TD>    protected PDDocument document;</TD></TR><TR><TD CLASS="l">199</TD><TD>    /**</TD></TR><TR><TD CLASS="l">200</TD><TD>     * The stream to write the output to.</TD></TR><TR><TD CLASS="l">201</TD><TD>     */</TD></TR><TR><TD CLASS="l">202</TD><TD>    protected Writer output;</TD></TR><TR><TD CLASS="l">203</TD><TD> </TD></TR><TR><TD CLASS="l">204</TD><TD>    /**</TD></TR><TR><TD CLASS="l">205</TD><TD>     * The normalizer is used to remove text ligatures/presentation forms</TD></TR><TR><TD CLASS="l">206</TD><TD>     * and to correct the direction of right to left text, such as Arabic and Hebrew.</TD></TR><TR><TD CLASS="l">207</TD><TD>     */</TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">208</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private TextNormalize normalize = null;</TD></TR><TR><TD CLASS="l">209</TD><TD> </TD></TR><TR><TD CLASS="l">210</TD><TD>    /**</TD></TR><TR><TD CLASS="l">211</TD><TD>     * True if we started a paragraph but haven't ended it</TD></TR><TR><TD CLASS="l">212</TD><TD>     * yet.</TD></TR><TR><TD CLASS="l">213</TD><TD>     */</TD></TR><TR><TD CLASS="l">214</TD><TD>    private boolean inParagraph;</TD></TR><TR><TD CLASS="l">215</TD><TD> </TD></TR><TR><TD CLASS="l">216</TD><TD>    /**</TD></TR><TR><TD CLASS="l">217</TD><TD>     * Instantiate a new PDFTextStripper object. This object will load</TD></TR><TR><TD CLASS="l">218</TD><TD>     * properties from PDFTextStripper.properties and will not do</TD></TR><TR><TD CLASS="l">219</TD><TD>     * anything special to convert the text to a more encoding-specific</TD></TR><TR><TD CLASS="l">220</TD><TD>     * output.</TD></TR><TR><TD CLASS="l">221</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="5">222</A></TD><TD>     * @throws IOException If there is an error loading the properties.</TD></TR><TR><TD CLASS="l">223</TD><TD>     */</TD></TR><TR><TD CLASS="l">224</TD><TD>    public PDFTextStripper() throws IOException</TD></TR><TR><TD CLASS="l">225</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">226</TD><TD>        super( ResourceLoader.loadProperties(</TD></TR><TR><TD CLASS="l">227</TD><TD>                &#34;org/apache/pdfbox/resources/PDFTextStripper.properties&#34;, true ) );</TD></TR><TR CLASS="z"><TD CLASS="l">228</TD><TD>        this.outputEncoding = null;</TD></TR><TR CLASS="z"><TD CLASS="l">229</TD><TD>        normalize = new TextNormalize(this.outputEncoding);</TD></TR><TR CLASS="z"><TD CLASS="l">230</TD><TD>    }</TD></TR><TR><TD CLASS="l">231</TD><TD> </TD></TR><TR><TD CLASS="l">232</TD><TD>    /**</TD></TR><TR><TD CLASS="l">233</TD><TD>     * Instantiate a new PDFTextStripper object.  Loading all of the operator mappings</TD></TR><TR><TD CLASS="l">234</TD><TD>     * from the properties object that is passed in.  Does not convert the text</TD></TR><TR><TD CLASS="l">235</TD><TD>     * to more encoding-specific output.</TD></TR><TR><TD CLASS="l">236</TD><TD>     *</TD></TR><TR><TD CLASS="l">237</TD><TD>     * @param props The properties containing the mapping of operators to PDFOperator</TD></TR><TR><TD CLASS="l">238</TD><TD>     * classes.</TD></TR><TR><TD CLASS="l">239</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="6">240</A></TD><TD>     * @throws IOException If there is an error reading the properties.</TD></TR><TR><TD CLASS="l">241</TD><TD>     */</TD></TR><TR><TD CLASS="l">242</TD><TD>    public PDFTextStripper( Properties props ) throws IOException</TD></TR><TR><TD CLASS="l">243</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">244</TD><TD>        super( props );</TD></TR><TR CLASS="z"><TD CLASS="l">245</TD><TD>        this.outputEncoding = null;</TD></TR><TR CLASS="z"><TD CLASS="l">246</TD><TD>        normalize = new TextNormalize(this.outputEncoding);</TD></TR><TR CLASS="z"><TD CLASS="l">247</TD><TD>    }</TD></TR><TR><TD CLASS="l">248</TD><TD>    /**</TD></TR><TR><TD CLASS="l">249</TD><TD>     * Instantiate a new PDFTextStripper object. This object will load</TD></TR><TR><TD CLASS="l">250</TD><TD>     * properties from PDFTextStripper.properties and will apply</TD></TR><TR><TD CLASS="l">251</TD><TD>     * encoding-specific conversions to the output text.</TD></TR><TR><TD CLASS="l">252</TD><TD>     *</TD></TR><TR><TD CLASS="l">253</TD><TD>     * @param encoding The encoding that the output will be written in.</TD></TR><TR><TD CLASS="l"><A NAME="34">254</A></TD><TD>     * @throws IOException If there is an error reading the properties.</TD></TR><TR><TD CLASS="l">255</TD><TD>     */</TD></TR><TR><TD CLASS="l">256</TD><TD>    public PDFTextStripper( String encoding ) throws IOException</TD></TR><TR><TD CLASS="l">257</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">258</TD><TD>        super( ResourceLoader.loadProperties(</TD></TR><TR><TD CLASS="l">259</TD><TD>                &#34;org/apache/pdfbox/resources/PDFTextStripper.properties&#34;, true ));</TD></TR><TR CLASS="c"><TD CLASS="l">260</TD><TD>        this.outputEncoding = encoding;</TD></TR><TR CLASS="c"><TD CLASS="l">261</TD><TD>        normalize = new TextNormalize(this.outputEncoding);</TD></TR><TR CLASS="c"><TD CLASS="l">262</TD><TD>    }</TD></TR><TR><TD CLASS="l">263</TD><TD> </TD></TR><TR><TD CLASS="l">264</TD><TD>    /**</TD></TR><TR><TD CLASS="l">265</TD><TD>     * This will return the text of a document.  See writeText. &lt;br /&gt;</TD></TR><TR><TD CLASS="l">266</TD><TD>     * NOTE: The document must not be encrypted when coming into this method.</TD></TR><TR><TD CLASS="l">267</TD><TD>     *</TD></TR><TR><TD CLASS="l">268</TD><TD>     * @param doc The document to get the text from.</TD></TR><TR><TD CLASS="l">269</TD><TD>     * @return The text of the PDF document.</TD></TR><TR><TD CLASS="l"><A NAME="47">270</A></TD><TD>     * @throws IOException if the doc state is invalid or it is encrypted.</TD></TR><TR><TD CLASS="l">271</TD><TD>     */</TD></TR><TR><TD CLASS="l">272</TD><TD>    public String getText( PDDocument doc ) throws IOException</TD></TR><TR><TD CLASS="l">273</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">274</TD><TD>        StringWriter outputStream = new StringWriter();</TD></TR><TR CLASS="c"><TD CLASS="l">275</TD><TD>        writeText( doc, outputStream );</TD></TR><TR CLASS="c"><TD CLASS="l">276</TD><TD>        return outputStream.toString();</TD></TR><TR><TD CLASS="l">277</TD><TD>    }</TD></TR><TR><TD CLASS="l">278</TD><TD> </TD></TR><TR><TD CLASS="l">279</TD><TD>    /**</TD></TR><TR><TD CLASS="l">280</TD><TD>     * @deprecated</TD></TR><TR><TD CLASS="l">281</TD><TD>     * @see PDFTextStripper#getText( PDDocument )</TD></TR><TR><TD CLASS="l">282</TD><TD>     * @param doc The document to extract the text from.</TD></TR><TR><TD CLASS="l">283</TD><TD>     * @return The document text.</TD></TR><TR><TD CLASS="l"><A NAME="12">284</A></TD><TD>     * @throws IOException If there is an error extracting the text.</TD></TR><TR><TD CLASS="l">285</TD><TD>     */</TD></TR><TR><TD CLASS="l">286</TD><TD>    public String getText( COSDocument doc ) throws IOException</TD></TR><TR><TD CLASS="l">287</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">288</TD><TD>        return getText( new PDDocument( doc ) );</TD></TR><TR><TD CLASS="l">289</TD><TD>    }</TD></TR><TR><TD CLASS="l">290</TD><TD> </TD></TR><TR><TD CLASS="l">291</TD><TD>    /**</TD></TR><TR><TD CLASS="l">292</TD><TD>     * @deprecated</TD></TR><TR><TD CLASS="l">293</TD><TD>     * @see PDFTextStripper#writeText( PDDocument, Writer )</TD></TR><TR><TD CLASS="l">294</TD><TD>     * @param doc The document to extract the text.</TD></TR><TR><TD CLASS="l">295</TD><TD>     * @param outputStream The stream to write the text to.</TD></TR><TR><TD CLASS="l"><A NAME="23">296</A></TD><TD>     * @throws IOException If there is an error extracting the text.</TD></TR><TR><TD CLASS="l">297</TD><TD>     */</TD></TR><TR><TD CLASS="l">298</TD><TD>    public void writeText( COSDocument doc, Writer outputStream ) throws IOException</TD></TR><TR><TD CLASS="l">299</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">300</TD><TD>        writeText( new PDDocument( doc ), outputStream );</TD></TR><TR CLASS="z"><TD CLASS="l">301</TD><TD>    }</TD></TR><TR><TD CLASS="l">302</TD><TD> </TD></TR><TR><TD CLASS="l">303</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="4a">304</A></TD><TD>     * {@inheritDoc}</TD></TR><TR><TD CLASS="l">305</TD><TD>     */</TD></TR><TR><TD CLASS="l">306</TD><TD>    public void resetEngine()</TD></TR><TR><TD CLASS="l">307</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">308</TD><TD>        super.resetEngine();</TD></TR><TR CLASS="c"><TD CLASS="l">309</TD><TD>        currentPageNo = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">310</TD><TD>        document = null;</TD></TR><TR CLASS="c"><TD CLASS="l">311</TD><TD>        if (charactersByArticle != null)</TD></TR><TR><TD CLASS="l">312</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">313</TD><TD>            charactersByArticle.clear();</TD></TR><TR><TD CLASS="l">314</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">315</TD><TD>        if (characterListMapping != null)</TD></TR><TR><TD CLASS="l">316</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">317</TD><TD>            characterListMapping.clear();</TD></TR><TR><TD CLASS="l">318</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">319</TD><TD>        startBookmark = null;</TD></TR><TR CLASS="c"><TD CLASS="l">320</TD><TD>        endBookmark = null;</TD></TR><TR CLASS="c"><TD CLASS="l">321</TD><TD>    }</TD></TR><TR><TD CLASS="l">322</TD><TD>    </TD></TR><TR><TD CLASS="l">323</TD><TD>    /**</TD></TR><TR><TD CLASS="l">324</TD><TD>     * This will take a PDDocument and write the text of that document to the print writer.</TD></TR><TR><TD CLASS="l">325</TD><TD>     *</TD></TR><TR><TD CLASS="l">326</TD><TD>     * @param doc The document to get the data from.</TD></TR><TR><TD CLASS="l">327</TD><TD>     * @param outputStream The location to put the text.</TD></TR><TR><TD CLASS="l">328</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="28">329</A></TD><TD>     * @throws IOException If the doc is in an invalid state.</TD></TR><TR><TD CLASS="l">330</TD><TD>     */</TD></TR><TR><TD CLASS="l">331</TD><TD>    public void writeText( PDDocument doc, Writer outputStream ) throws IOException</TD></TR><TR><TD CLASS="l">332</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">333</TD><TD>        resetEngine();</TD></TR><TR CLASS="c"><TD CLASS="l">334</TD><TD>        document = doc;</TD></TR><TR CLASS="c"><TD CLASS="l">335</TD><TD>        output = outputStream;</TD></TR><TR CLASS="c"><TD CLASS="l">336</TD><TD>        if (getAddMoreFormatting()) </TD></TR><TR><TD CLASS="l">337</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">338</TD><TD>            paragraphEnd = lineSeparator;</TD></TR><TR CLASS="z"><TD CLASS="l">339</TD><TD>            pageStart = lineSeparator;</TD></TR><TR CLASS="z"><TD CLASS="l">340</TD><TD>            articleStart = lineSeparator;</TD></TR><TR CLASS="z"><TD CLASS="l">341</TD><TD>            articleEnd = lineSeparator;</TD></TR><TR><TD CLASS="l">342</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">343</TD><TD>        startDocument(document);</TD></TR><TR CLASS="c"><TD CLASS="l">344</TD><TD>        processPages( document.getDocumentCatalog().getAllPages() );</TD></TR><TR CLASS="c"><TD CLASS="l">345</TD><TD>        endDocument(document);</TD></TR><TR CLASS="c"><TD CLASS="l">346</TD><TD>    }</TD></TR><TR><TD CLASS="l">347</TD><TD> </TD></TR><TR><TD CLASS="l">348</TD><TD>    /**</TD></TR><TR><TD CLASS="l">349</TD><TD>     * This will process all of the pages and the text that is in them.</TD></TR><TR><TD CLASS="l">350</TD><TD>     *</TD></TR><TR><TD CLASS="l">351</TD><TD>     * @param pages The pages object in the document.</TD></TR><TR><TD CLASS="l">352</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="26">353</A></TD><TD>     * @throws IOException If there is an error parsing the text.</TD></TR><TR><TD CLASS="l">354</TD><TD>     */</TD></TR><TR><TD CLASS="l">355</TD><TD>    protected void processPages( List&lt;COSObjectable&gt; pages ) throws IOException</TD></TR><TR><TD CLASS="l">356</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">357</TD><TD>        if( startBookmark != null )</TD></TR><TR><TD CLASS="l">358</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">359</TD><TD>            startBookmarkPageNumber = getPageNumber( startBookmark, pages );</TD></TR><TR><TD CLASS="l">360</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">361</TD><TD>        if( endBookmark != null )</TD></TR><TR><TD CLASS="l">362</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">363</TD><TD>            endBookmarkPageNumber = getPageNumber( endBookmark, pages );</TD></TR><TR><TD CLASS="l">364</TD><TD>        }</TD></TR><TR><TD CLASS="l">365</TD><TD> </TD></TR><TR CLASS="p"><TD TITLE="33% line coverage (7 out of 21 instructions)" CLASS="l">366</TD><TD TITLE="33% line coverage (7 out of 21 instructions)">        if( startBookmarkPageNumber == -1 &amp;&amp; startBookmark != null &amp;&amp;</TD></TR><TR><TD CLASS="l">367</TD><TD>                endBookmarkPageNumber == -1 &amp;&amp; endBookmark != null &amp;&amp;</TD></TR><TR CLASS="z"><TD CLASS="l">368</TD><TD>                startBookmark.getCOSObject() == endBookmark.getCOSObject() )</TD></TR><TR><TD CLASS="l">369</TD><TD>        {</TD></TR><TR><TD CLASS="l">370</TD><TD>            //this is a special case where both the start and end bookmark</TD></TR><TR><TD CLASS="l">371</TD><TD>            //are the same but point to nothing.  In this case</TD></TR><TR><TD CLASS="l">372</TD><TD>            //we will not extract any text.</TD></TR><TR CLASS="z"><TD CLASS="l">373</TD><TD>            startBookmarkPageNumber = 0;</TD></TR><TR CLASS="z"><TD CLASS="l">374</TD><TD>            endBookmarkPageNumber = 0;</TD></TR><TR><TD CLASS="l">375</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">376</TD><TD>        Iterator&lt;COSObjectable&gt; pageIter = pages.iterator();</TD></TR><TR CLASS="c"><TD CLASS="l">377</TD><TD>        while( pageIter.hasNext() )</TD></TR><TR><TD CLASS="l">378</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">379</TD><TD>            PDPage nextPage = (PDPage)pageIter.next();</TD></TR><TR CLASS="c"><TD CLASS="l">380</TD><TD>            PDStream contentStream = nextPage.getContents();</TD></TR><TR CLASS="c"><TD CLASS="l">381</TD><TD>            currentPageNo++;</TD></TR><TR CLASS="c"><TD CLASS="l">382</TD><TD>            if( contentStream != null )</TD></TR><TR><TD CLASS="l">383</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">384</TD><TD>                COSStream contents = contentStream.getStream();</TD></TR><TR CLASS="c"><TD CLASS="l">385</TD><TD>                processPage( nextPage, contents );</TD></TR><TR><TD CLASS="l">386</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">387</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="c">388</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">389</TD><TD> </TD></TR><TR><TD CLASS="l">390</TD><TD>    private int getPageNumber( PDOutlineItem bookmark, List&lt;COSObjectable&gt; allPages ) throws IOException</TD></TR><TR><TD CLASS="l">391</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">392</TD><TD>        int pageNumber = -1;</TD></TR><TR CLASS="z"><TD CLASS="l">393</TD><TD>        PDPage page = bookmark.findDestinationPage( document );</TD></TR><TR CLASS="z"><TD CLASS="l">394</TD><TD>        if( page != null )</TD></TR><TR><TD CLASS="l">395</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">396</TD><TD>            pageNumber = allPages.indexOf( page )+1;//use one based indexing</TD></TR><TR><TD CLASS="l">397</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">398</TD><TD>        return pageNumber;</TD></TR><TR><TD CLASS="l">399</TD><TD>    }</TD></TR><TR><TD CLASS="l">400</TD><TD> </TD></TR><TR><TD CLASS="l">401</TD><TD>    /**</TD></TR><TR><TD CLASS="l">402</TD><TD>     * This method is available for subclasses of this class.  It will be called before processing</TD></TR><TR><TD CLASS="l">403</TD><TD>     * of the document start.</TD></TR><TR><TD CLASS="l">404</TD><TD>     *</TD></TR><TR><TD CLASS="l">405</TD><TD>     * @param pdf The PDF document that is being processed.</TD></TR><TR><TD CLASS="l">406</TD><TD>     * @throws IOException If an IO error occurs.</TD></TR><TR><TD CLASS="l"><A NAME="57">407</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">408</TD><TD>    protected void startDocument(PDDocument pdf) throws IOException</TD></TR><TR><TD CLASS="l">409</TD><TD>    {</TD></TR><TR><TD CLASS="l">410</TD><TD>        // no default implementation, but available for subclasses</TD></TR><TR CLASS="c"><TD CLASS="l">411</TD><TD>    }</TD></TR><TR><TD CLASS="l">412</TD><TD> </TD></TR><TR><TD CLASS="l">413</TD><TD>    /**</TD></TR><TR><TD CLASS="l">414</TD><TD>     * This method is available for subclasses of this class.  It will be called after processing</TD></TR><TR><TD CLASS="l">415</TD><TD>     * of the document finishes.</TD></TR><TR><TD CLASS="l">416</TD><TD>     *</TD></TR><TR><TD CLASS="l">417</TD><TD>     * @param pdf The PDF document that is being processed.</TD></TR><TR><TD CLASS="l">418</TD><TD>     * @throws IOException If an IO error occurs.</TD></TR><TR><TD CLASS="l"><A NAME="37">419</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">420</TD><TD>    protected void endDocument(PDDocument pdf ) throws IOException</TD></TR><TR><TD CLASS="l">421</TD><TD>    {</TD></TR><TR><TD CLASS="l">422</TD><TD>        // no default implementation, but available for subclasses</TD></TR><TR CLASS="c"><TD CLASS="l">423</TD><TD>    }</TD></TR><TR><TD CLASS="l">424</TD><TD> </TD></TR><TR><TD CLASS="l">425</TD><TD>    /**</TD></TR><TR><TD CLASS="l">426</TD><TD>     * This will process the contents of a page.</TD></TR><TR><TD CLASS="l">427</TD><TD>     *</TD></TR><TR><TD CLASS="l">428</TD><TD>     * @param page The page to process.</TD></TR><TR><TD CLASS="l">429</TD><TD>     * @param content The contents of the page.</TD></TR><TR><TD CLASS="l">430</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="2c">431</A></TD><TD>     * @throws IOException If there is an error processing the page.</TD></TR><TR><TD CLASS="l">432</TD><TD>     */</TD></TR><TR><TD CLASS="l">433</TD><TD>    protected void processPage( PDPage page, COSStream content ) throws IOException</TD></TR><TR><TD CLASS="l">434</TD><TD>    {</TD></TR><TR CLASS="p"><TD TITLE="64% line coverage (18 out of 28 instructions)" CLASS="l">435</TD><TD TITLE="64% line coverage (18 out of 28 instructions)">        if( currentPageNo &gt;= startPage &amp;&amp; currentPageNo &lt;= endPage &amp;&amp;</TD></TR><TR><TD CLASS="l">436</TD><TD>                (startBookmarkPageNumber == -1 || currentPageNo &gt;= startBookmarkPageNumber ) &amp;&amp;</TD></TR><TR><TD CLASS="l">437</TD><TD>                (endBookmarkPageNumber == -1 || currentPageNo &lt;= endBookmarkPageNumber ))</TD></TR><TR><TD CLASS="l">438</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">439</TD><TD>            startPage( page );</TD></TR><TR CLASS="c"><TD CLASS="l">440</TD><TD>            pageArticles = page.getThreadBeads();</TD></TR><TR CLASS="c"><TD CLASS="l">441</TD><TD>            int numberOfArticleSections = 1 + pageArticles.size() * 2;</TD></TR><TR CLASS="c"><TD CLASS="l">442</TD><TD>            if( !shouldSeparateByBeads )</TD></TR><TR><TD CLASS="l">443</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">444</TD><TD>                numberOfArticleSections = 1;</TD></TR><TR><TD CLASS="l">445</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">446</TD><TD>            int originalSize = charactersByArticle.size();</TD></TR><TR CLASS="c"><TD CLASS="l">447</TD><TD>            charactersByArticle.setSize( numberOfArticleSections );</TD></TR><TR CLASS="c"><TD CLASS="l">448</TD><TD>            for( int i=0; i&lt;numberOfArticleSections; i++ )</TD></TR><TR><TD CLASS="l">449</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">450</TD><TD>                if( numberOfArticleSections &lt; originalSize )</TD></TR><TR><TD CLASS="l">451</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">452</TD><TD>                    ((List&lt;TextPosition&gt;)charactersByArticle.get( i )).clear();</TD></TR><TR><TD CLASS="l">453</TD><TD>                }</TD></TR><TR><TD CLASS="l">454</TD><TD>                else</TD></TR><TR><TD CLASS="l">455</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">456</TD><TD>                    charactersByArticle.set( i, new ArrayList&lt;TextPosition&gt;() );</TD></TR><TR><TD CLASS="l">457</TD><TD>                }</TD></TR><TR><TD CLASS="l">458</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">459</TD><TD>            characterListMapping.clear();</TD></TR><TR CLASS="c"><TD CLASS="l">460</TD><TD>            processStream( page, page.findResources(), content );</TD></TR><TR CLASS="c"><TD CLASS="l">461</TD><TD>            writePage();</TD></TR><TR CLASS="c"><TD CLASS="l">462</TD><TD>            endPage( page );</TD></TR><TR><TD CLASS="l">463</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">464</TD><TD>    }</TD></TR><TR><TD CLASS="l">465</TD><TD> </TD></TR><TR><TD CLASS="l">466</TD><TD>    /**</TD></TR><TR><TD CLASS="l">467</TD><TD>     * Start a new article, which is typically defined as a column</TD></TR><TR><TD CLASS="l">468</TD><TD>     * on a single page (also referred to as a bead).  This assumes</TD></TR><TR><TD CLASS="l">469</TD><TD>     * that the primary direction of text is left to right.  </TD></TR><TR><TD CLASS="l">470</TD><TD>     * Default implementation is to do nothing.  Subclasses</TD></TR><TR><TD CLASS="l">471</TD><TD>     * may provide additional information.</TD></TR><TR><TD CLASS="l">472</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="20">473</A></TD><TD>     * @throws IOException If there is any error writing to the stream.</TD></TR><TR><TD CLASS="l">474</TD><TD>     */</TD></TR><TR><TD CLASS="l">475</TD><TD>    protected void startArticle() throws IOException</TD></TR><TR><TD CLASS="l">476</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">477</TD><TD>        startArticle(true);</TD></TR><TR CLASS="z"><TD CLASS="l">478</TD><TD>    }</TD></TR><TR><TD CLASS="l">479</TD><TD> </TD></TR><TR><TD CLASS="l">480</TD><TD>    /**</TD></TR><TR><TD CLASS="l">481</TD><TD>     * Start a new article, which is typically defined as a column</TD></TR><TR><TD CLASS="l">482</TD><TD>     * on a single page (also referred to as a bead).  </TD></TR><TR><TD CLASS="l">483</TD><TD>     * Default implementation is to do nothing.  Subclasses</TD></TR><TR><TD CLASS="l">484</TD><TD>     * may provide additional information.</TD></TR><TR><TD CLASS="l">485</TD><TD>     *</TD></TR><TR><TD CLASS="l">486</TD><TD>     * @param isltr true if primary direction of text is left to right.</TD></TR><TR><TD CLASS="l"><A NAME="56">487</A></TD><TD>     * @throws IOException If there is any error writing to the stream.</TD></TR><TR><TD CLASS="l">488</TD><TD>     */</TD></TR><TR><TD CLASS="l">489</TD><TD>    protected void startArticle(boolean isltr) throws IOException</TD></TR><TR><TD CLASS="l">490</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">491</TD><TD>        output.write(getArticleStart());</TD></TR><TR CLASS="c"><TD CLASS="l">492</TD><TD>    }</TD></TR><TR><TD CLASS="l">493</TD><TD> </TD></TR><TR><TD CLASS="l">494</TD><TD>    /**</TD></TR><TR><TD CLASS="l">495</TD><TD>     * End an article.  Default implementation is to do nothing.  Subclasses</TD></TR><TR><TD CLASS="l">496</TD><TD>     * may provide additional information.</TD></TR><TR><TD CLASS="l">497</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="36">498</A></TD><TD>     * @throws IOException If there is any error writing to the stream.</TD></TR><TR><TD CLASS="l">499</TD><TD>     */</TD></TR><TR><TD CLASS="l">500</TD><TD>    protected void endArticle() throws IOException</TD></TR><TR><TD CLASS="l">501</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">502</TD><TD>        output.write(getArticleEnd());</TD></TR><TR CLASS="c"><TD CLASS="l">503</TD><TD>    }</TD></TR><TR><TD CLASS="l">504</TD><TD> </TD></TR><TR><TD CLASS="l">505</TD><TD>    /**</TD></TR><TR><TD CLASS="l">506</TD><TD>     * Start a new page.  Default implementation is to do nothing.  Subclasses</TD></TR><TR><TD CLASS="l">507</TD><TD>     * may provide additional information.</TD></TR><TR><TD CLASS="l">508</TD><TD>     *</TD></TR><TR><TD CLASS="l">509</TD><TD>     * @param page The page we are about to process.</TD></TR><TR><TD CLASS="l">510</TD><TD>     *</TD></TR><TR><TD CLASS="l">511</TD><TD>     * @throws IOException If there is any error writing to the stream.</TD></TR><TR><TD CLASS="l"><A NAME="58">512</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">513</TD><TD>    protected void startPage( PDPage page ) throws IOException</TD></TR><TR><TD CLASS="l">514</TD><TD>    {</TD></TR><TR><TD CLASS="l">515</TD><TD>        //default is to do nothing.</TD></TR><TR CLASS="c"><TD CLASS="l">516</TD><TD>    }</TD></TR><TR><TD CLASS="l">517</TD><TD> </TD></TR><TR><TD CLASS="l">518</TD><TD>    /**</TD></TR><TR><TD CLASS="l">519</TD><TD>     * End a page.  Default implementation is to do nothing.  Subclasses</TD></TR><TR><TD CLASS="l">520</TD><TD>     * may provide additional information.</TD></TR><TR><TD CLASS="l">521</TD><TD>     *</TD></TR><TR><TD CLASS="l">522</TD><TD>     * @param page The page we are about to process.</TD></TR><TR><TD CLASS="l">523</TD><TD>     *</TD></TR><TR><TD CLASS="l">524</TD><TD>     * @throws IOException If there is any error writing to the stream.</TD></TR><TR><TD CLASS="l"><A NAME="38">525</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">526</TD><TD>    protected void endPage( PDPage page ) throws IOException</TD></TR><TR><TD CLASS="l">527</TD><TD>    {</TD></TR><TR><TD CLASS="l">528</TD><TD>        //default is to do nothing</TD></TR><TR CLASS="c"><TD CLASS="l">529</TD><TD>    }</TD></TR><TR><TD CLASS="l">530</TD><TD> </TD></TR><TR><TD CLASS="l">531</TD><TD>    private static final float ENDOFLASTTEXTX_RESET_VALUE = -1;</TD></TR><TR><TD CLASS="l">532</TD><TD>    private static final float MAXYFORLINE_RESET_VALUE = -Float.MAX_VALUE;</TD></TR><TR><TD CLASS="l">533</TD><TD>    private static final float EXPECTEDSTARTOFNEXTWORDX_RESET_VALUE = -Float.MAX_VALUE;</TD></TR><TR><TD CLASS="l">534</TD><TD>    private static final float MAXHEIGHTFORLINE_RESET_VALUE = -1;</TD></TR><TR><TD CLASS="l">535</TD><TD>    private static final float MINYTOPFORLINE_RESET_VALUE = Float.MAX_VALUE;</TD></TR><TR><TD CLASS="l">536</TD><TD>    private static final float LASTWORDSPACING_RESET_VALUE = -1;</TD></TR><TR><TD CLASS="l">537</TD><TD> </TD></TR><TR><TD CLASS="l">538</TD><TD>    /**</TD></TR><TR><TD CLASS="l">539</TD><TD>     * This will print the text of the processed page to &#34;output&#34;.</TD></TR><TR><TD CLASS="l">540</TD><TD>     * It will estimate, based on the coordinates of the text, where</TD></TR><TR><TD CLASS="l">541</TD><TD>     * newlines and word spacings should be placed. The text will be</TD></TR><TR><TD CLASS="l">542</TD><TD>     * sorted only if that feature was enabled. </TD></TR><TR><TD CLASS="l">543</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="31">544</A></TD><TD>     * @throws IOException If there is an error writing the text.</TD></TR><TR><TD CLASS="l">545</TD><TD>     */</TD></TR><TR><TD CLASS="l">546</TD><TD>    protected void writePage() throws IOException</TD></TR><TR><TD CLASS="l">547</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">548</TD><TD>        float maxYForLine = MAXYFORLINE_RESET_VALUE;</TD></TR><TR CLASS="c"><TD CLASS="l">549</TD><TD>        float minYTopForLine = MINYTOPFORLINE_RESET_VALUE;</TD></TR><TR CLASS="c"><TD CLASS="l">550</TD><TD>        float endOfLastTextX = ENDOFLASTTEXTX_RESET_VALUE;</TD></TR><TR CLASS="c"><TD CLASS="l">551</TD><TD>        float lastWordSpacing = LASTWORDSPACING_RESET_VALUE;</TD></TR><TR CLASS="c"><TD CLASS="l">552</TD><TD>        float maxHeightForLine = MAXHEIGHTFORLINE_RESET_VALUE;</TD></TR><TR CLASS="c"><TD CLASS="l">553</TD><TD>        PositionWrapper lastPosition = null;</TD></TR><TR CLASS="c"><TD CLASS="l">554</TD><TD>        PositionWrapper lastLineStartPosition = null;</TD></TR><TR><TD CLASS="l">555</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">556</TD><TD>        boolean startOfPage = true;//flag to indicate start of page</TD></TR><TR CLASS="c"><TD CLASS="l">557</TD><TD>        boolean startOfArticle = true;</TD></TR><TR CLASS="c"><TD CLASS="l">558</TD><TD>        if(charactersByArticle.size() &gt; 0) </TD></TR><TR><TD CLASS="l">559</TD><TD>        { </TD></TR><TR CLASS="c"><TD CLASS="l">560</TD><TD>            writePageStart();</TD></TR><TR><TD CLASS="l">561</TD><TD>        }</TD></TR><TR><TD CLASS="l">562</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">563</TD><TD>        for( int i = 0; i &lt; charactersByArticle.size(); i++)</TD></TR><TR><TD CLASS="l">564</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">565</TD><TD>            List&lt;TextPosition&gt; textList = charactersByArticle.get( i );</TD></TR><TR CLASS="c"><TD CLASS="l">566</TD><TD>            if( getSortByPosition() )</TD></TR><TR><TD CLASS="l">567</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">568</TD><TD>                TextPositionComparator comparator = new TextPositionComparator();</TD></TR><TR><TD CLASS="l">569</TD><TD>                // because the TextPositionComparator is not transitive, but </TD></TR><TR><TD CLASS="l">570</TD><TD>                // JDK7+ enforces transitivity on comparators, we need to use</TD></TR><TR><TD CLASS="l">571</TD><TD>                // a custom quicksort implementation (which is slower, unfortunately).</TD></TR><TR CLASS="z"><TD CLASS="l">572</TD><TD>                if(useCustomQuicksort) </TD></TR><TR><TD CLASS="l">573</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">574</TD><TD>                    QuickSort.sort( textList, comparator );</TD></TR><TR><TD CLASS="l">575</TD><TD>                } </TD></TR><TR><TD CLASS="l">576</TD><TD>                else </TD></TR><TR><TD CLASS="l">577</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">578</TD><TD>                    Collections.sort( textList, comparator );</TD></TR><TR><TD CLASS="l">579</TD><TD>                }</TD></TR><TR><TD CLASS="l">580</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">581</TD><TD>            Iterator&lt;TextPosition&gt; textIter = textList.iterator();</TD></TR><TR><TD CLASS="l">582</TD><TD>            /* Before we can display the text, we need to do some normalizing.</TD></TR><TR><TD CLASS="l">583</TD><TD>             * Arabic and Hebrew text is right to left and is typically stored</TD></TR><TR><TD CLASS="l">584</TD><TD>             * in its logical format, which means that the rightmost character is</TD></TR><TR><TD CLASS="l">585</TD><TD>             * stored first, followed by the second character from the right etc.</TD></TR><TR><TD CLASS="l">586</TD><TD>             * However, PDF stores the text in presentation form, which is left to</TD></TR><TR><TD CLASS="l">587</TD><TD>             * right.  We need to do some normalization to convert the PDF data to</TD></TR><TR><TD CLASS="l">588</TD><TD>             * the proper logical output format.</TD></TR><TR><TD CLASS="l">589</TD><TD>             *</TD></TR><TR><TD CLASS="l">590</TD><TD>             * Note that if we did not sort the text, then the output of reversing the</TD></TR><TR><TD CLASS="l">591</TD><TD>             * text is undefined and can sometimes produce worse output then not trying</TD></TR><TR><TD CLASS="l">592</TD><TD>             * to reverse the order.  Sorting should be done for these languages.</TD></TR><TR><TD CLASS="l">593</TD><TD>             * */</TD></TR><TR><TD CLASS="l">594</TD><TD> </TD></TR><TR><TD CLASS="l">595</TD><TD>            /* First step is to determine if we have any right to left text, and</TD></TR><TR><TD CLASS="l">596</TD><TD>             * if so, is it dominant. */</TD></TR><TR CLASS="c"><TD CLASS="l">597</TD><TD>            int ltrCnt = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">598</TD><TD>            int rtlCnt = 0;</TD></TR><TR><TD CLASS="l">599</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">600</TD><TD>            while( textIter.hasNext() )</TD></TR><TR><TD CLASS="l">601</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">602</TD><TD>                TextPosition position = (TextPosition)textIter.next();</TD></TR><TR CLASS="c"><TD CLASS="l">603</TD><TD>                String stringValue = position.getCharacter();</TD></TR><TR CLASS="c"><TD CLASS="l">604</TD><TD>                for (int a = 0; a &lt; stringValue.length(); a++)</TD></TR><TR><TD CLASS="l">605</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">606</TD><TD>                    byte dir = Character.getDirectionality(stringValue.charAt(a));</TD></TR><TR CLASS="c"><TD CLASS="l">607</TD><TD>                    if ((dir == Character.DIRECTIONALITY_LEFT_TO_RIGHT ) ||</TD></TR><TR><TD CLASS="l">608</TD><TD>                            (dir == Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING) ||</TD></TR><TR><TD CLASS="l">609</TD><TD>                            (dir == Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE ))</TD></TR><TR><TD CLASS="l">610</TD><TD>                    {</TD></TR><TR CLASS="c"><TD CLASS="l">611</TD><TD>                        ltrCnt++;</TD></TR><TR><TD CLASS="l">612</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">613</TD><TD>                    else if ((dir == Character.DIRECTIONALITY_RIGHT_TO_LEFT ) ||</TD></TR><TR><TD CLASS="l">614</TD><TD>                            (dir == Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC) ||</TD></TR><TR><TD CLASS="l">615</TD><TD>                            (dir == Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING) ||</TD></TR><TR><TD CLASS="l">616</TD><TD>                            (dir == Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE ))</TD></TR><TR><TD CLASS="l">617</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">618</TD><TD>                        rtlCnt++;</TD></TR><TR><TD CLASS="l">619</TD><TD>                    }</TD></TR><TR><TD CLASS="l">620</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">621</TD><TD>            }</TD></TR><TR><TD CLASS="l">622</TD><TD>            // choose the dominant direction</TD></TR><TR CLASS="p"><TD TITLE="80% line coverage (8 out of 10 instructions)" CLASS="l">623</TD><TD TITLE="80% line coverage (8 out of 10 instructions)">            boolean isRtlDominant = rtlCnt &gt; ltrCnt;</TD></TR><TR><TD CLASS="l">624</TD><TD> </TD></TR><TR CLASS="p"><TD TITLE="92% line coverage (11 out of 12 instructions)" CLASS="l">625</TD><TD TITLE="92% line coverage (11 out of 12 instructions)">            startArticle(!isRtlDominant);</TD></TR><TR CLASS="c"><TD CLASS="l">626</TD><TD>            startOfArticle = true;</TD></TR><TR><TD CLASS="l">627</TD><TD>            // we will later use this to skip reordering</TD></TR><TR CLASS="p"><TD TITLE="89% line coverage (16 out of 18 instructions)" CLASS="l">628</TD><TD TITLE="89% line coverage (16 out of 18 instructions)">            boolean hasRtl = rtlCnt &gt; 0;</TD></TR><TR><TD CLASS="l">629</TD><TD> </TD></TR><TR><TD CLASS="l">630</TD><TD>            /* Now cycle through to print the text.</TD></TR><TR><TD CLASS="l">631</TD><TD>             * We queue up a line at a time before we print so that we can convert</TD></TR><TR><TD CLASS="l">632</TD><TD>             * the line from presentation form to logical form (if needed). </TD></TR><TR><TD CLASS="l">633</TD><TD>             */</TD></TR><TR CLASS="c"><TD CLASS="l">634</TD><TD>            List&lt;TextPosition&gt; line = new ArrayList&lt;TextPosition&gt;();</TD></TR><TR><TD CLASS="l">635</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">636</TD><TD>            textIter = textList.iterator();    // start from the beginning again</TD></TR><TR><TD CLASS="l">637</TD><TD>            /* PDF files don't always store spaces. We will need to guess where we should add</TD></TR><TR><TD CLASS="l">638</TD><TD>             * spaces based on the distances between TextPositions. Historically, this was done</TD></TR><TR><TD CLASS="l">639</TD><TD>             * based on the size of the space character provided by the font. In general, this worked</TD></TR><TR><TD CLASS="l">640</TD><TD>             * but there were cases where it did not work. Calculating the average character width</TD></TR><TR><TD CLASS="l">641</TD><TD>             * and using that as a metric works better in some cases but fails in some cases where the</TD></TR><TR><TD CLASS="l">642</TD><TD>             * spacing worked. So we use both. NOTE: Adobe reader also fails on some of these examples.</TD></TR><TR><TD CLASS="l">643</TD><TD>             */</TD></TR><TR><TD CLASS="l">644</TD><TD>            //Keeps track of the previous average character width</TD></TR><TR CLASS="c"><TD CLASS="l">645</TD><TD>            float previousAveCharWidth = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">646</TD><TD>            while( textIter.hasNext() )</TD></TR><TR><TD CLASS="l">647</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">648</TD><TD>                TextPosition position = (TextPosition)textIter.next();</TD></TR><TR CLASS="c"><TD CLASS="l">649</TD><TD>                PositionWrapper current = new PositionWrapper(position);</TD></TR><TR CLASS="c"><TD CLASS="l">650</TD><TD>                String characterValue = position.getCharacter();</TD></TR><TR><TD CLASS="l">651</TD><TD> </TD></TR><TR><TD CLASS="l">652</TD><TD>                //Resets the average character width when we see a change in font</TD></TR><TR><TD CLASS="l">653</TD><TD>                // or a change in the font size</TD></TR><TR CLASS="c"><TD CLASS="l">654</TD><TD>                if(lastPosition != null &amp;&amp; ((position.getFont() != lastPosition.getTextPosition().getFont())</TD></TR><TR CLASS="c"><TD CLASS="l">655</TD><TD>                        || (position.getFontSize() != lastPosition.getTextPosition().getFontSize())))</TD></TR><TR><TD CLASS="l">656</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">657</TD><TD>                    previousAveCharWidth = -1;</TD></TR><TR><TD CLASS="l">658</TD><TD>                }</TD></TR><TR><TD CLASS="l">659</TD><TD> </TD></TR><TR><TD CLASS="l">660</TD><TD>                float positionX;</TD></TR><TR><TD CLASS="l">661</TD><TD>                float positionY;</TD></TR><TR><TD CLASS="l">662</TD><TD>                float positionWidth;</TD></TR><TR><TD CLASS="l">663</TD><TD>                float positionHeight;</TD></TR><TR><TD CLASS="l">664</TD><TD> </TD></TR><TR><TD CLASS="l">665</TD><TD>                /* If we are sorting, then we need to use the text direction</TD></TR><TR><TD CLASS="l">666</TD><TD>                 * adjusted coordinates, because they were used in the sorting. */</TD></TR><TR CLASS="c"><TD CLASS="l">667</TD><TD>                if (getSortByPosition())</TD></TR><TR><TD CLASS="l">668</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">669</TD><TD>                    positionX = position.getXDirAdj();</TD></TR><TR CLASS="z"><TD CLASS="l">670</TD><TD>                    positionY = position.getYDirAdj();</TD></TR><TR CLASS="z"><TD CLASS="l">671</TD><TD>                    positionWidth = position.getWidthDirAdj();</TD></TR><TR CLASS="z"><TD CLASS="l">672</TD><TD>                    positionHeight = position.getHeightDir();</TD></TR><TR><TD CLASS="l">673</TD><TD>                }</TD></TR><TR><TD CLASS="l">674</TD><TD>                else</TD></TR><TR><TD CLASS="l">675</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">676</TD><TD>                    positionX = position.getX();</TD></TR><TR CLASS="c"><TD CLASS="l">677</TD><TD>                    positionY = position.getY();</TD></TR><TR CLASS="c"><TD CLASS="l">678</TD><TD>                    positionWidth = position.getWidth();</TD></TR><TR CLASS="c"><TD CLASS="l">679</TD><TD>                    positionHeight = position.getHeight();</TD></TR><TR><TD CLASS="l">680</TD><TD>                }</TD></TR><TR><TD CLASS="l">681</TD><TD> </TD></TR><TR><TD CLASS="l">682</TD><TD>                //The current amount of characters in a word</TD></TR><TR CLASS="c"><TD CLASS="l">683</TD><TD>                int wordCharCount = position.getIndividualWidths().length;</TD></TR><TR><TD CLASS="l">684</TD><TD> </TD></TR><TR><TD CLASS="l">685</TD><TD>                /* Estimate the expected width of the space based on the</TD></TR><TR><TD CLASS="l">686</TD><TD>                 * space character with some margin. */</TD></TR><TR CLASS="c"><TD CLASS="l">687</TD><TD>                float wordSpacing = position.getWidthOfSpace();</TD></TR><TR CLASS="c"><TD CLASS="l">688</TD><TD>                float deltaSpace = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">689</TD><TD>                if ((wordSpacing == 0) || (wordSpacing == Float.NaN))</TD></TR><TR><TD CLASS="l">690</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">691</TD><TD>                    deltaSpace = Float.MAX_VALUE;</TD></TR><TR><TD CLASS="l">692</TD><TD>                }</TD></TR><TR><TD CLASS="l">693</TD><TD>                else</TD></TR><TR><TD CLASS="l">694</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">695</TD><TD>                    if( lastWordSpacing &lt; 0 )</TD></TR><TR><TD CLASS="l">696</TD><TD>                    {</TD></TR><TR CLASS="c"><TD CLASS="l">697</TD><TD>                        deltaSpace = (wordSpacing * getSpacingTolerance());</TD></TR><TR><TD CLASS="l">698</TD><TD>                    }</TD></TR><TR><TD CLASS="l">699</TD><TD>                    else</TD></TR><TR><TD CLASS="l">700</TD><TD>                    {</TD></TR><TR CLASS="c"><TD CLASS="l">701</TD><TD>                        deltaSpace = (((wordSpacing+lastWordSpacing)/2f)* getSpacingTolerance());</TD></TR><TR><TD CLASS="l">702</TD><TD>                    }</TD></TR><TR><TD CLASS="l">703</TD><TD>                }</TD></TR><TR><TD CLASS="l">704</TD><TD> </TD></TR><TR><TD CLASS="l">705</TD><TD>                /* Estimate the expected width of the space based on the</TD></TR><TR><TD CLASS="l">706</TD><TD>                 * average character width with some margin. This calculation does not</TD></TR><TR><TD CLASS="l">707</TD><TD>                 * make a true average (average of averages) but we found that it gave the</TD></TR><TR><TD CLASS="l">708</TD><TD>                 * best results after numerous experiments. Based on experiments we also found that</TD></TR><TR><TD CLASS="l">709</TD><TD>                 * .3 worked well. */</TD></TR><TR CLASS="c"><TD CLASS="l">710</TD><TD>                float averageCharWidth = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">711</TD><TD>                if(previousAveCharWidth &lt; 0)</TD></TR><TR><TD CLASS="l">712</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">713</TD><TD>                    averageCharWidth = (positionWidth/wordCharCount);</TD></TR><TR><TD CLASS="l">714</TD><TD>                }</TD></TR><TR><TD CLASS="l">715</TD><TD>                else</TD></TR><TR><TD CLASS="l">716</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">717</TD><TD>                    averageCharWidth = (previousAveCharWidth + (positionWidth/wordCharCount))/2f;</TD></TR><TR><TD CLASS="l">718</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">719</TD><TD>                float deltaCharWidth = (averageCharWidth * getAverageCharTolerance());</TD></TR><TR><TD CLASS="l">720</TD><TD> </TD></TR><TR><TD CLASS="l">721</TD><TD>                //Compares the values obtained by the average method and the wordSpacing method and picks</TD></TR><TR><TD CLASS="l">722</TD><TD>                //the smaller number.</TD></TR><TR CLASS="c"><TD CLASS="l">723</TD><TD>                float expectedStartOfNextWordX = EXPECTEDSTARTOFNEXTWORDX_RESET_VALUE;</TD></TR><TR CLASS="c"><TD CLASS="l">724</TD><TD>                if(endOfLastTextX != ENDOFLASTTEXTX_RESET_VALUE)</TD></TR><TR><TD CLASS="l">725</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">726</TD><TD>                    if(deltaCharWidth &gt; deltaSpace)</TD></TR><TR><TD CLASS="l">727</TD><TD>                    {</TD></TR><TR CLASS="c"><TD CLASS="l">728</TD><TD>                        expectedStartOfNextWordX = endOfLastTextX + deltaSpace;</TD></TR><TR><TD CLASS="l">729</TD><TD>                    }</TD></TR><TR><TD CLASS="l">730</TD><TD>                    else</TD></TR><TR><TD CLASS="l">731</TD><TD>                    {</TD></TR><TR CLASS="c"><TD CLASS="l">732</TD><TD>                        expectedStartOfNextWordX = endOfLastTextX + deltaCharWidth;</TD></TR><TR><TD CLASS="l">733</TD><TD>                    }</TD></TR><TR><TD CLASS="l">734</TD><TD>                }</TD></TR><TR><TD CLASS="l">735</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">736</TD><TD>                if( lastPosition != null )</TD></TR><TR><TD CLASS="l">737</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">738</TD><TD>                    if(startOfArticle)</TD></TR><TR><TD CLASS="l">739</TD><TD>                    {</TD></TR><TR CLASS="c"><TD CLASS="l">740</TD><TD>                        lastPosition.setArticleStart();</TD></TR><TR CLASS="c"><TD CLASS="l">741</TD><TD>                        startOfArticle = false;</TD></TR><TR><TD CLASS="l">742</TD><TD>                    }</TD></TR><TR><TD CLASS="l">743</TD><TD>                    // RDD - Here we determine whether this text object is on the current</TD></TR><TR><TD CLASS="l">744</TD><TD>                    // line.  We use the lastBaselineFontSize to handle the superscript</TD></TR><TR><TD CLASS="l">745</TD><TD>                    // case, and the size of the current font to handle the subscript case.</TD></TR><TR><TD CLASS="l">746</TD><TD>                    // Text must overlap with the last rendered baseline text by at least</TD></TR><TR><TD CLASS="l">747</TD><TD>                    // a small amount in order to be considered as being on the same line.</TD></TR><TR><TD CLASS="l">748</TD><TD> </TD></TR><TR><TD CLASS="l">749</TD><TD>                    /* XXX BC: In theory, this check should really check if the next char is in full range</TD></TR><TR><TD CLASS="l">750</TD><TD>                     * seen in this line. This is what I tried to do with minYTopForLine, but this caused a lot</TD></TR><TR><TD CLASS="l">751</TD><TD>                     * of regression test failures.  So, I'm leaving it be for now. */</TD></TR><TR CLASS="c"><TD CLASS="l">752</TD><TD>                    if(!overlap(positionY, positionHeight, maxYForLine, maxHeightForLine))</TD></TR><TR><TD CLASS="l">753</TD><TD>                    {</TD></TR><TR CLASS="c"><TD CLASS="l">754</TD><TD>                        writeLine(normalize(line,isRtlDominant,hasRtl),isRtlDominant);</TD></TR><TR CLASS="c"><TD CLASS="l">755</TD><TD>                        line.clear();</TD></TR><TR CLASS="c"><TD CLASS="l">756</TD><TD>                        lastLineStartPosition = </TD></TR><TR CLASS="c"><TD CLASS="l">757</TD><TD>                            handleLineSeparation(current, lastPosition, lastLineStartPosition, maxHeightForLine);</TD></TR><TR CLASS="c"><TD CLASS="l">758</TD><TD>                        endOfLastTextX = ENDOFLASTTEXTX_RESET_VALUE;</TD></TR><TR CLASS="c"><TD CLASS="l">759</TD><TD>                        expectedStartOfNextWordX = EXPECTEDSTARTOFNEXTWORDX_RESET_VALUE;</TD></TR><TR CLASS="c"><TD CLASS="l">760</TD><TD>                        maxYForLine = MAXYFORLINE_RESET_VALUE;</TD></TR><TR CLASS="c"><TD CLASS="l">761</TD><TD>                        maxHeightForLine = MAXHEIGHTFORLINE_RESET_VALUE;</TD></TR><TR CLASS="c"><TD CLASS="l">762</TD><TD>                        minYTopForLine = MINYTOPFORLINE_RESET_VALUE;</TD></TR><TR><TD CLASS="l">763</TD><TD>                    }</TD></TR><TR><TD CLASS="l">764</TD><TD>                    //Test if our TextPosition starts after a new word would be expected to start.</TD></TR><TR CLASS="c"><TD CLASS="l">765</TD><TD>                    if (expectedStartOfNextWordX != EXPECTEDSTARTOFNEXTWORDX_RESET_VALUE </TD></TR><TR><TD CLASS="l">766</TD><TD>                            &amp;&amp; expectedStartOfNextWordX &lt; positionX &amp;&amp;</TD></TR><TR><TD CLASS="l">767</TD><TD>                            //only bother adding a space if the last character was not a space</TD></TR><TR CLASS="c"><TD CLASS="l">768</TD><TD>                             lastPosition.getTextPosition().getCharacter() != null &amp;&amp;</TD></TR><TR CLASS="c"><TD CLASS="l">769</TD><TD>                            !lastPosition.getTextPosition().getCharacter().endsWith( &#34; &#34; ) )</TD></TR><TR><TD CLASS="l">770</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">771</TD><TD>                        line.add(WordSeparator.getSeparator());</TD></TR><TR><TD CLASS="l">772</TD><TD>                    }</TD></TR><TR><TD CLASS="l">773</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">774</TD><TD>                if (positionY &gt;= maxYForLine)</TD></TR><TR><TD CLASS="l">775</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">776</TD><TD>                    maxYForLine = positionY;</TD></TR><TR><TD CLASS="l">777</TD><TD>                }</TD></TR><TR><TD CLASS="l">778</TD><TD>                // RDD - endX is what PDF considers to be the x coordinate of the</TD></TR><TR><TD CLASS="l">779</TD><TD>                // end position of the text.  We use it in computing our metrics below.</TD></TR><TR CLASS="c"><TD CLASS="l">780</TD><TD>                endOfLastTextX = positionX + positionWidth;</TD></TR><TR><TD CLASS="l">781</TD><TD> </TD></TR><TR><TD CLASS="l">782</TD><TD>                // add it to the list</TD></TR><TR CLASS="c"><TD CLASS="l">783</TD><TD>                if (characterValue != null)</TD></TR><TR><TD CLASS="l">784</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">785</TD><TD>                    if(startOfPage &amp;&amp; lastPosition==null)</TD></TR><TR><TD CLASS="l">786</TD><TD>                    {</TD></TR><TR CLASS="c"><TD CLASS="l">787</TD><TD>                        writeParagraphStart();//not sure this is correct for RTL?</TD></TR><TR><TD CLASS="l">788</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">789</TD><TD>                    line.add(position);</TD></TR><TR><TD CLASS="l">790</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">791</TD><TD>                maxHeightForLine = Math.max( maxHeightForLine, positionHeight );</TD></TR><TR CLASS="c"><TD CLASS="l">792</TD><TD>                minYTopForLine = Math.min(minYTopForLine,positionY - positionHeight);</TD></TR><TR CLASS="c"><TD CLASS="l">793</TD><TD>                lastPosition = current;</TD></TR><TR CLASS="c"><TD CLASS="l">794</TD><TD>                if(startOfPage)</TD></TR><TR><TD CLASS="l">795</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">796</TD><TD>                    lastPosition.setParagraphStart();</TD></TR><TR CLASS="c"><TD CLASS="l">797</TD><TD>                    lastPosition.setLineStart();</TD></TR><TR CLASS="c"><TD CLASS="l">798</TD><TD>                    lastLineStartPosition = lastPosition;</TD></TR><TR CLASS="c"><TD CLASS="l">799</TD><TD>                    startOfPage=false;</TD></TR><TR><TD CLASS="l">800</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">801</TD><TD>                lastWordSpacing = wordSpacing;</TD></TR><TR CLASS="c"><TD CLASS="l">802</TD><TD>                previousAveCharWidth = averageCharWidth;</TD></TR><TR CLASS="c"><TD CLASS="l">803</TD><TD>            }</TD></TR><TR><TD CLASS="l">804</TD><TD>            // print the final line</TD></TR><TR CLASS="c"><TD CLASS="l">805</TD><TD>            if (line.size() &gt; 0)</TD></TR><TR><TD CLASS="l">806</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">807</TD><TD>                writeLine(normalize(line,isRtlDominant,hasRtl),isRtlDominant);</TD></TR><TR CLASS="c"><TD CLASS="l">808</TD><TD>                writeParagraphEnd();</TD></TR><TR><TD CLASS="l">809</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">810</TD><TD>            endArticle();</TD></TR><TR><TD CLASS="l">811</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">812</TD><TD>        writePageEnd();</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="2b">813</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">814</TD><TD> </TD></TR><TR><TD CLASS="l">815</TD><TD>    private boolean overlap( float y1, float height1, float y2, float height2 )</TD></TR><TR><TD CLASS="l">816</TD><TD>    {</TD></TR><TR CLASS="p"><TD TITLE="80% line coverage (24 out of 30 instructions)" CLASS="l">817</TD><TD TITLE="80% line coverage (24 out of 30 instructions)">        return within( y1, y2, .1f) || (y2 &lt;= y1 &amp;&amp; y2 &gt;= y1-height1) ||</TD></TR><TR><TD CLASS="l">818</TD><TD>        (y1 &lt;= y2 &amp;&amp; y1 &gt;= y2-height2);</TD></TR><TR><TD CLASS="l">819</TD><TD>    }</TD></TR><TR><TD CLASS="l">820</TD><TD> </TD></TR><TR><TD CLASS="l">821</TD><TD>    /**</TD></TR><TR><TD CLASS="l">822</TD><TD>     * Write the page separator value to the output stream.</TD></TR><TR><TD CLASS="l">823</TD><TD>     * @throws IOException</TD></TR><TR><TD CLASS="l">824</TD><TD>     *             If there is a problem writing out the pageseparator to the document.</TD></TR><TR><TD CLASS="l">825</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="22">826</A></TD><TD>    protected void writePageSeperator() throws IOException</TD></TR><TR><TD CLASS="l">827</TD><TD>    {</TD></TR><TR><TD CLASS="l">828</TD><TD>        // RDD - newline at end of flush - required for end of page (so that the top</TD></TR><TR><TD CLASS="l">829</TD><TD>        // of the next page starts on its own line.</TD></TR><TR CLASS="z"><TD CLASS="l">830</TD><TD>        output.write(getPageSeparator());</TD></TR><TR CLASS="z"><TD CLASS="l">831</TD><TD>        output.flush();</TD></TR><TR CLASS="z"><TD CLASS="l">832</TD><TD>    }</TD></TR><TR><TD CLASS="l">833</TD><TD> </TD></TR><TR><TD CLASS="l">834</TD><TD>    /**</TD></TR><TR><TD CLASS="l">835</TD><TD>     * Write the line separator value to the output stream.</TD></TR><TR><TD CLASS="l">836</TD><TD>     * @throws IOException</TD></TR><TR><TD CLASS="l"><A NAME="5a">837</A></TD><TD>     *             If there is a problem writing out the lineseparator to the document.</TD></TR><TR><TD CLASS="l">838</TD><TD>     */</TD></TR><TR><TD CLASS="l">839</TD><TD>    protected void writeLineSeparator( ) throws IOException</TD></TR><TR><TD CLASS="l">840</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">841</TD><TD>        output.write(getLineSeparator());</TD></TR><TR CLASS="c"><TD CLASS="l">842</TD><TD>    }</TD></TR><TR><TD CLASS="l">843</TD><TD> </TD></TR><TR><TD CLASS="l">844</TD><TD> </TD></TR><TR><TD CLASS="l">845</TD><TD>    /**</TD></TR><TR><TD CLASS="l">846</TD><TD>     * Write the word separator value to the output stream.</TD></TR><TR><TD CLASS="l">847</TD><TD>     * @throws IOException</TD></TR><TR><TD CLASS="l"><A NAME="24">848</A></TD><TD>     *             If there is a problem writing out the wordseparator to the document.</TD></TR><TR><TD CLASS="l">849</TD><TD>     */</TD></TR><TR><TD CLASS="l">850</TD><TD>    protected void writeWordSeparator() throws IOException</TD></TR><TR><TD CLASS="l">851</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">852</TD><TD>        output.write(getWordSeparator());</TD></TR><TR CLASS="z"><TD CLASS="l">853</TD><TD>    }</TD></TR><TR><TD CLASS="l">854</TD><TD> </TD></TR><TR><TD CLASS="l">855</TD><TD>    /**</TD></TR><TR><TD CLASS="l">856</TD><TD>     * Write the string in TextPosition to the output stream.</TD></TR><TR><TD CLASS="l">857</TD><TD>     *</TD></TR><TR><TD CLASS="l">858</TD><TD>     * @param text The text to write to the stream.</TD></TR><TR><TD CLASS="l"><A NAME="21">859</A></TD><TD>     * @throws IOException If there is an error when writing the text.</TD></TR><TR><TD CLASS="l">860</TD><TD>     */</TD></TR><TR><TD CLASS="l">861</TD><TD>    protected void writeCharacters( TextPosition text ) throws IOException</TD></TR><TR><TD CLASS="l">862</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">863</TD><TD>        output.write( text.getCharacter() );</TD></TR><TR CLASS="z"><TD CLASS="l">864</TD><TD>    }</TD></TR><TR><TD CLASS="l">865</TD><TD> </TD></TR><TR><TD CLASS="l">866</TD><TD>    /**</TD></TR><TR><TD CLASS="l">867</TD><TD>     * Write a Java string to the output stream. The default implementation will ignore the &lt;code&gt;textPositions&lt;/code&gt;</TD></TR><TR><TD CLASS="l">868</TD><TD>     * and just calls {@link #writeString(String)}.</TD></TR><TR><TD CLASS="l">869</TD><TD>     *</TD></TR><TR><TD CLASS="l">870</TD><TD>     * @param text The text to write to the stream.</TD></TR><TR><TD CLASS="l">871</TD><TD>     * @param textPositions The TextPositions belonging to the text.</TD></TR><TR><TD CLASS="l"><A NAME="5f">872</A></TD><TD>     * @throws IOException If there is an error when writing the text.</TD></TR><TR><TD CLASS="l">873</TD><TD>     */</TD></TR><TR><TD CLASS="l">874</TD><TD>    protected void writeString(String text, List&lt;TextPosition&gt; textPositions) throws IOException</TD></TR><TR><TD CLASS="l">875</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">876</TD><TD>        writeString(text);</TD></TR><TR CLASS="c"><TD CLASS="l">877</TD><TD>    }</TD></TR><TR><TD CLASS="l">878</TD><TD> </TD></TR><TR><TD CLASS="l">879</TD><TD>    /**</TD></TR><TR><TD CLASS="l">880</TD><TD>     * Write a Java string to the output stream.</TD></TR><TR><TD CLASS="l">881</TD><TD>     *</TD></TR><TR><TD CLASS="l">882</TD><TD>     * @param text The text to write to the stream.</TD></TR><TR><TD CLASS="l"><A NAME="5e">883</A></TD><TD>     * @throws IOException If there is an error when writing the text.</TD></TR><TR><TD CLASS="l">884</TD><TD>     */</TD></TR><TR><TD CLASS="l">885</TD><TD>    protected void writeString( String text ) throws IOException</TD></TR><TR><TD CLASS="l">886</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">887</TD><TD>        output.write( text );</TD></TR><TR CLASS="c"><TD CLASS="l">888</TD><TD>    }</TD></TR><TR><TD CLASS="l">889</TD><TD> </TD></TR><TR><TD CLASS="l">890</TD><TD>    /**</TD></TR><TR><TD CLASS="l">891</TD><TD>     * This will determine of two floating point numbers are within a specified variance.</TD></TR><TR><TD CLASS="l">892</TD><TD>     *</TD></TR><TR><TD CLASS="l">893</TD><TD>     * @param first The first number to compare to.</TD></TR><TR><TD CLASS="l">894</TD><TD>     * @param second The second number to compare to.</TD></TR><TR><TD CLASS="l"><A NAME="59">895</A></TD><TD>     * @param variance The allowed variance.</TD></TR><TR><TD CLASS="l">896</TD><TD>     */</TD></TR><TR><TD CLASS="l">897</TD><TD>    private boolean within( float first, float second, float variance )</TD></TR><TR><TD CLASS="l">898</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">899</TD><TD>        return second &lt; first + variance &amp;&amp; second &gt; first - variance;</TD></TR><TR><TD CLASS="l">900</TD><TD>    }</TD></TR><TR><TD CLASS="l">901</TD><TD> </TD></TR><TR><TD CLASS="l">902</TD><TD>    /**</TD></TR><TR><TD CLASS="l">903</TD><TD>     * This will process a TextPosition object and add the</TD></TR><TR><TD CLASS="l">904</TD><TD>     * text to the list of characters on a page.  It takes care of</TD></TR><TR><TD CLASS="l">905</TD><TD>     * overlapping text.</TD></TR><TR><TD CLASS="l">906</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="27">907</A></TD><TD>     * @param text The text to process.</TD></TR><TR><TD CLASS="l">908</TD><TD>     */</TD></TR><TR><TD CLASS="l">909</TD><TD>    protected void processTextPosition( TextPosition text )</TD></TR><TR><TD CLASS="l">910</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">911</TD><TD>        boolean showCharacter = true;</TD></TR><TR CLASS="c"><TD CLASS="l">912</TD><TD>        if( suppressDuplicateOverlappingText )</TD></TR><TR><TD CLASS="l">913</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">914</TD><TD>            showCharacter = false;</TD></TR><TR CLASS="c"><TD CLASS="l">915</TD><TD>            String textCharacter = text.getCharacter();</TD></TR><TR CLASS="c"><TD CLASS="l">916</TD><TD>            float textX = text.getX();</TD></TR><TR CLASS="c"><TD CLASS="l">917</TD><TD>            float textY = text.getY();</TD></TR><TR CLASS="c"><TD CLASS="l">918</TD><TD>            TreeMap&lt;Float, TreeSet&lt;Float&gt;&gt; sameTextCharacters = characterListMapping.get( textCharacter );</TD></TR><TR CLASS="c"><TD CLASS="l">919</TD><TD>            if( sameTextCharacters == null )</TD></TR><TR><TD CLASS="l">920</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">921</TD><TD>                sameTextCharacters = new TreeMap&lt;Float, TreeSet&lt;Float&gt;&gt;();</TD></TR><TR CLASS="c"><TD CLASS="l">922</TD><TD>                characterListMapping.put( textCharacter, sameTextCharacters );</TD></TR><TR><TD CLASS="l">923</TD><TD>            }</TD></TR><TR><TD CLASS="l">924</TD><TD>            // RDD - Here we compute the value that represents the end of the rendered</TD></TR><TR><TD CLASS="l">925</TD><TD>            // text.  This value is used to determine whether subsequent text rendered</TD></TR><TR><TD CLASS="l">926</TD><TD>            // on the same line overwrites the current text.</TD></TR><TR><TD CLASS="l">927</TD><TD>            //</TD></TR><TR><TD CLASS="l">928</TD><TD>            // We subtract any positive padding to handle cases where extreme amounts</TD></TR><TR><TD CLASS="l">929</TD><TD>            // of padding are applied, then backed off (not sure why this is done, but there</TD></TR><TR><TD CLASS="l">930</TD><TD>            // are cases where the padding is on the order of 10x the character width, and</TD></TR><TR><TD CLASS="l">931</TD><TD>            // the TJ just backs up to compensate after each character).  Also, we subtract</TD></TR><TR><TD CLASS="l">932</TD><TD>            // an amount to allow for kerning (a percentage of the width of the last</TD></TR><TR><TD CLASS="l">933</TD><TD>            // character).</TD></TR><TR><TD CLASS="l">934</TD><TD>            //</TD></TR><TR CLASS="c"><TD CLASS="l">935</TD><TD>            boolean suppressCharacter = false;</TD></TR><TR CLASS="c"><TD CLASS="l">936</TD><TD>            float tolerance = (text.getWidth()/textCharacter.length())/3.0f;</TD></TR><TR><TD CLASS="l">937</TD><TD>            </TD></TR><TR CLASS="c"><TD CLASS="l">938</TD><TD>            SortedMap&lt;Float, TreeSet&lt;Float&gt;&gt; xMatches =</TD></TR><TR CLASS="c"><TD CLASS="l">939</TD><TD>                sameTextCharacters.subMap(textX - tolerance, textX + tolerance );</TD></TR><TR CLASS="c"><TD CLASS="l">940</TD><TD>            for (TreeSet&lt;Float&gt; xMatch : xMatches.values()) </TD></TR><TR><TD CLASS="l">941</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">942</TD><TD>                SortedSet&lt;Float&gt; yMatches =</TD></TR><TR CLASS="c"><TD CLASS="l">943</TD><TD>                    xMatch.subSet(textY - tolerance , textY + tolerance );</TD></TR><TR CLASS="c"><TD CLASS="l">944</TD><TD>                if (!yMatches.isEmpty()) </TD></TR><TR><TD CLASS="l">945</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">946</TD><TD>                    suppressCharacter = true;</TD></TR><TR CLASS="z"><TD CLASS="l">947</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">948</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">949</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">950</TD><TD>            if( !suppressCharacter )</TD></TR><TR><TD CLASS="l">951</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">952</TD><TD>                TreeSet&lt;Float&gt; ySet = sameTextCharacters.get(textX);</TD></TR><TR CLASS="c"><TD CLASS="l">953</TD><TD>                if (ySet == null) </TD></TR><TR><TD CLASS="l">954</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">955</TD><TD>                    ySet = new TreeSet&lt;Float&gt;();</TD></TR><TR CLASS="c"><TD CLASS="l">956</TD><TD>                    sameTextCharacters.put( textX,  ySet );</TD></TR><TR><TD CLASS="l">957</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">958</TD><TD>                ySet.add( textY );</TD></TR><TR CLASS="c"><TD CLASS="l">959</TD><TD>                showCharacter = true;</TD></TR><TR><TD CLASS="l">960</TD><TD>            }</TD></TR><TR><TD CLASS="l">961</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">962</TD><TD>        if( showCharacter )</TD></TR><TR><TD CLASS="l">963</TD><TD>        {</TD></TR><TR><TD CLASS="l">964</TD><TD>            //if we are showing the character then we need to determine which</TD></TR><TR><TD CLASS="l">965</TD><TD>            //article it belongs to.</TD></TR><TR CLASS="c"><TD CLASS="l">966</TD><TD>            int foundArticleDivisionIndex = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">967</TD><TD>            int notFoundButFirstLeftAndAboveArticleDivisionIndex = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">968</TD><TD>            int notFoundButFirstLeftArticleDivisionIndex = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">969</TD><TD>            int notFoundButFirstAboveArticleDivisionIndex = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">970</TD><TD>            float x = text.getX();</TD></TR><TR CLASS="c"><TD CLASS="l">971</TD><TD>            float y = text.getY();</TD></TR><TR CLASS="c"><TD CLASS="l">972</TD><TD>            if( shouldSeparateByBeads )</TD></TR><TR><TD CLASS="l">973</TD><TD>            {</TD></TR><TR CLASS="p"><TD TITLE="62% line coverage (8 out of 13 instructions)" CLASS="l">974</TD><TD TITLE="62% line coverage (8 out of 13 instructions)">                for( int i=0; i&lt;pageArticles.size() &amp;&amp; foundArticleDivisionIndex == -1; i++ )</TD></TR><TR><TD CLASS="l">975</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">976</TD><TD>                    PDThreadBead bead = (PDThreadBead)pageArticles.get( i );</TD></TR><TR CLASS="z"><TD CLASS="l">977</TD><TD>                    if( bead != null )</TD></TR><TR><TD CLASS="l">978</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">979</TD><TD>                        PDRectangle rect = bead.getRectangle();</TD></TR><TR CLASS="z"><TD CLASS="l">980</TD><TD>                        if( rect.contains( x, y ) )</TD></TR><TR><TD CLASS="l">981</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">982</TD><TD>                            foundArticleDivisionIndex = i*2+1;</TD></TR><TR><TD CLASS="l">983</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">984</TD><TD>                        else if( (x &lt; rect.getLowerLeftX() ||</TD></TR><TR CLASS="z"><TD CLASS="l">985</TD><TD>                                y &lt; rect.getUpperRightY()) &amp;&amp;</TD></TR><TR><TD CLASS="l">986</TD><TD>                                notFoundButFirstLeftAndAboveArticleDivisionIndex == -1)</TD></TR><TR><TD CLASS="l">987</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">988</TD><TD>                            notFoundButFirstLeftAndAboveArticleDivisionIndex = i*2;</TD></TR><TR><TD CLASS="l">989</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">990</TD><TD>                        else if( x &lt; rect.getLowerLeftX() &amp;&amp;</TD></TR><TR><TD CLASS="l">991</TD><TD>                                notFoundButFirstLeftArticleDivisionIndex == -1)</TD></TR><TR><TD CLASS="l">992</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">993</TD><TD>                            notFoundButFirstLeftArticleDivisionIndex = i*2;</TD></TR><TR><TD CLASS="l">994</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">995</TD><TD>                        else if( y &lt; rect.getUpperRightY() &amp;&amp;</TD></TR><TR><TD CLASS="l">996</TD><TD>                                notFoundButFirstAboveArticleDivisionIndex == -1)</TD></TR><TR><TD CLASS="l">997</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">998</TD><TD>                            notFoundButFirstAboveArticleDivisionIndex = i*2;</TD></TR><TR><TD CLASS="l">999</TD><TD>                        }</TD></TR><TR CLASS="z"><TD CLASS="l">1000</TD><TD>                    }</TD></TR><TR><TD CLASS="l">1001</TD><TD>                    else</TD></TR><TR><TD CLASS="l">1002</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">1003</TD><TD>                        foundArticleDivisionIndex = 0;</TD></TR><TR><TD CLASS="l">1004</TD><TD>                    }</TD></TR><TR><TD CLASS="l">1005</TD><TD>                }</TD></TR><TR><TD CLASS="l">1006</TD><TD>            }</TD></TR><TR><TD CLASS="l">1007</TD><TD>            else</TD></TR><TR><TD CLASS="l">1008</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1009</TD><TD>                foundArticleDivisionIndex = 0;</TD></TR><TR><TD CLASS="l">1010</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1011</TD><TD>            int articleDivisionIndex = -1;</TD></TR><TR CLASS="c"><TD CLASS="l">1012</TD><TD>            if( foundArticleDivisionIndex != -1 )</TD></TR><TR><TD CLASS="l">1013</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1014</TD><TD>                articleDivisionIndex = foundArticleDivisionIndex;</TD></TR><TR><TD CLASS="l">1015</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1016</TD><TD>            else if( notFoundButFirstLeftAndAboveArticleDivisionIndex != -1 )</TD></TR><TR><TD CLASS="l">1017</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1018</TD><TD>                articleDivisionIndex = notFoundButFirstLeftAndAboveArticleDivisionIndex;</TD></TR><TR><TD CLASS="l">1019</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1020</TD><TD>            else if( notFoundButFirstLeftArticleDivisionIndex != -1 )</TD></TR><TR><TD CLASS="l">1021</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1022</TD><TD>                articleDivisionIndex = notFoundButFirstLeftArticleDivisionIndex;</TD></TR><TR><TD CLASS="l">1023</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1024</TD><TD>            else if( notFoundButFirstAboveArticleDivisionIndex != -1 )</TD></TR><TR><TD CLASS="l">1025</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1026</TD><TD>                articleDivisionIndex = notFoundButFirstAboveArticleDivisionIndex;</TD></TR><TR><TD CLASS="l">1027</TD><TD>            }</TD></TR><TR><TD CLASS="l">1028</TD><TD>            else</TD></TR><TR><TD CLASS="l">1029</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">1030</TD><TD>                articleDivisionIndex = charactersByArticle.size()-1;</TD></TR><TR><TD CLASS="l">1031</TD><TD>            }</TD></TR><TR><TD CLASS="l">1032</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1033</TD><TD>            List&lt;TextPosition&gt; textList = (List&lt;TextPosition&gt;) charactersByArticle.get( articleDivisionIndex );</TD></TR><TR><TD CLASS="l">1034</TD><TD> </TD></TR><TR><TD CLASS="l">1035</TD><TD>            /* In the wild, some PDF encoded documents put diacritics (accents on</TD></TR><TR><TD CLASS="l">1036</TD><TD>             * top of characters) into a separate Tj element.  When displaying them</TD></TR><TR><TD CLASS="l">1037</TD><TD>             * graphically, the two chunks get overlayed.  With text output though,</TD></TR><TR><TD CLASS="l">1038</TD><TD>             * we need to do the overlay. This code recombines the diacritic with</TD></TR><TR><TD CLASS="l">1039</TD><TD>             * its associated character if the two are consecutive.</TD></TR><TR><TD CLASS="l">1040</TD><TD>             */ </TD></TR><TR CLASS="c"><TD CLASS="l">1041</TD><TD>            if(textList.isEmpty())</TD></TR><TR><TD CLASS="l">1042</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">1043</TD><TD>                textList.add(text);</TD></TR><TR><TD CLASS="l">1044</TD><TD>            }</TD></TR><TR><TD CLASS="l">1045</TD><TD>            else</TD></TR><TR><TD CLASS="l">1046</TD><TD>            {</TD></TR><TR><TD CLASS="l">1047</TD><TD>                /* test if we overlap the previous entry.  </TD></TR><TR><TD CLASS="l">1048</TD><TD>                 * Note that we are making an assumption that we need to only look back</TD></TR><TR><TD CLASS="l">1049</TD><TD>                 * one TextPosition to find what we are overlapping.  </TD></TR><TR><TD CLASS="l">1050</TD><TD>                 * This may not always be true. */</TD></TR><TR CLASS="c"><TD CLASS="l">1051</TD><TD>                TextPosition previousTextPosition = (TextPosition)textList.get(textList.size()-1);</TD></TR><TR CLASS="p"><TD TITLE="73% line coverage (11 out of 15 instructions)" CLASS="l">1052</TD><TD TITLE="73% line coverage (11 out of 15 instructions)">                if(text.isDiacritic() &amp;&amp; previousTextPosition.contains(text))</TD></TR><TR><TD CLASS="l">1053</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1054</TD><TD>                    previousTextPosition.mergeDiacritic(text, normalize);</TD></TR><TR><TD CLASS="l">1055</TD><TD>                }</TD></TR><TR><TD CLASS="l">1056</TD><TD>                /* If the previous TextPosition was the diacritic, merge it into this</TD></TR><TR><TD CLASS="l">1057</TD><TD>                 * one and remove it from the list. */</TD></TR><TR CLASS="p"><TD TITLE="43% line coverage (3 out of 7 instructions)" CLASS="l">1058</TD><TD TITLE="43% line coverage (3 out of 7 instructions)">                else if(previousTextPosition.isDiacritic() &amp;&amp; text.contains(previousTextPosition))</TD></TR><TR><TD CLASS="l">1059</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1060</TD><TD>                    text.mergeDiacritic(previousTextPosition, normalize);</TD></TR><TR CLASS="z"><TD CLASS="l">1061</TD><TD>                    textList.remove(textList.size()-1);</TD></TR><TR CLASS="z"><TD CLASS="l">1062</TD><TD>                    textList.add(text);</TD></TR><TR><TD CLASS="l">1063</TD><TD>                }</TD></TR><TR><TD CLASS="l">1064</TD><TD>                else</TD></TR><TR><TD CLASS="l">1065</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">1066</TD><TD>                    textList.add(text);</TD></TR><TR><TD CLASS="l">1067</TD><TD>                }</TD></TR><TR><TD CLASS="l">1068</TD><TD>            }</TD></TR><TR><TD CLASS="l">1069</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1070</TD><TD>    }</TD></TR><TR><TD CLASS="l">1071</TD><TD> </TD></TR><TR><TD CLASS="l">1072</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1073</TD><TD>     * This is the page that the text extraction will start on.  The pages start</TD></TR><TR><TD CLASS="l">1074</TD><TD>     * at page 1.  For example in a 5 page PDF document, if the start page is 1</TD></TR><TR><TD CLASS="l">1075</TD><TD>     * then all pages will be extracted.  If the start page is 4 then pages 4 and 5</TD></TR><TR><TD CLASS="l">1076</TD><TD>     * will be extracted.  The default value is 1.</TD></TR><TR><TD CLASS="l">1077</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="10">1078</A></TD><TD>     * @return Value of property startPage.</TD></TR><TR><TD CLASS="l">1079</TD><TD>     */</TD></TR><TR><TD CLASS="l">1080</TD><TD>    public int getStartPage()</TD></TR><TR><TD CLASS="l">1081</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1082</TD><TD>        return startPage;</TD></TR><TR><TD CLASS="l">1083</TD><TD>    }</TD></TR><TR><TD CLASS="l">1084</TD><TD> </TD></TR><TR><TD CLASS="l">1085</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1086</TD><TD>     * This will set the first page to be extracted by this class.</TD></TR><TR><TD CLASS="l">1087</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="55">1088</A></TD><TD>     * @param startPageValue New value of property startPage.</TD></TR><TR><TD CLASS="l">1089</TD><TD>     */</TD></TR><TR><TD CLASS="l">1090</TD><TD>    public void setStartPage(int startPageValue)</TD></TR><TR><TD CLASS="l">1091</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1092</TD><TD>        startPage = startPageValue;</TD></TR><TR CLASS="c"><TD CLASS="l">1093</TD><TD>    }</TD></TR><TR><TD CLASS="l">1094</TD><TD> </TD></TR><TR><TD CLASS="l">1095</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1096</TD><TD>     * This will get the last page that will be extracted.  This is inclusive,</TD></TR><TR><TD CLASS="l">1097</TD><TD>     * for example if a 5 page PDF an endPage value of 5 would extract the</TD></TR><TR><TD CLASS="l">1098</TD><TD>     * entire document, an end page of 2 would extract pages 1 and 2.  This defaults</TD></TR><TR><TD CLASS="l">1099</TD><TD>     * to Integer.MAX_VALUE such that all pages of the pdf will be extracted.</TD></TR><TR><TD CLASS="l">1100</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="a">1101</A></TD><TD>     * @return Value of property endPage.</TD></TR><TR><TD CLASS="l">1102</TD><TD>     */</TD></TR><TR><TD CLASS="l">1103</TD><TD>    public int getEndPage()</TD></TR><TR><TD CLASS="l">1104</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1105</TD><TD>        return endPage;</TD></TR><TR><TD CLASS="l">1106</TD><TD>    }</TD></TR><TR><TD CLASS="l">1107</TD><TD> </TD></TR><TR><TD CLASS="l">1108</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1109</TD><TD>     * This will set the last page to be extracted by this class.</TD></TR><TR><TD CLASS="l">1110</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="4d">1111</A></TD><TD>     * @param endPageValue New value of property endPage.</TD></TR><TR><TD CLASS="l">1112</TD><TD>     */</TD></TR><TR><TD CLASS="l">1113</TD><TD>    public void setEndPage(int endPageValue)</TD></TR><TR><TD CLASS="l">1114</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1115</TD><TD>        endPage = endPageValue;</TD></TR><TR CLASS="c"><TD CLASS="l">1116</TD><TD>    }</TD></TR><TR><TD CLASS="l">1117</TD><TD> </TD></TR><TR><TD CLASS="l">1118</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1119</TD><TD>     * Set the desired line separator for output text.  The line.separator</TD></TR><TR><TD CLASS="l">1120</TD><TD>     * system property is used if the line separator preference is not set</TD></TR><TR><TD CLASS="l">1121</TD><TD>     * explicitly using this method.</TD></TR><TR><TD CLASS="l">1122</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="4e">1123</A></TD><TD>     * @param separator The desired line separator string.</TD></TR><TR><TD CLASS="l">1124</TD><TD>     */</TD></TR><TR><TD CLASS="l">1125</TD><TD>    public void setLineSeparator(String separator)</TD></TR><TR><TD CLASS="l">1126</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1127</TD><TD>        lineSeparator = separator;</TD></TR><TR CLASS="c"><TD CLASS="l">1128</TD><TD>    }</TD></TR><TR><TD CLASS="l">1129</TD><TD> </TD></TR><TR><TD CLASS="l">1130</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1131</TD><TD>     * This will get the line separator.</TD></TR><TR><TD CLASS="l">1132</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="3f">1133</A></TD><TD>     * @return The desired line separator string.</TD></TR><TR><TD CLASS="l">1134</TD><TD>     */</TD></TR><TR><TD CLASS="l">1135</TD><TD>    public String getLineSeparator()</TD></TR><TR><TD CLASS="l">1136</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1137</TD><TD>        return lineSeparator;</TD></TR><TR><TD CLASS="l">1138</TD><TD>    }</TD></TR><TR><TD CLASS="l">1139</TD><TD> </TD></TR><TR><TD CLASS="l">1140</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1141</TD><TD>     * Set the desired page separator for output text.  The line.separator</TD></TR><TR><TD CLASS="l">1142</TD><TD>     * system property is used if the page separator preference is not set</TD></TR><TR><TD CLASS="l">1143</TD><TD>     * explicitly using this method.</TD></TR><TR><TD CLASS="l">1144</TD><TD>     *</TD></TR><TR><TD CLASS="l">1145</TD><TD>     * @param separator The desired page separator string.</TD></TR><TR><TD CLASS="l">1146</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="1b">1147</A></TD><TD>     * @deprecated use {@link #setPageStart(String) and {@link #setPageEnd(String)} instead</TD></TR><TR><TD CLASS="l">1148</TD><TD>     */</TD></TR><TR><TD CLASS="l">1149</TD><TD>    public void setPageSeparator(String separator)</TD></TR><TR><TD CLASS="l">1150</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1151</TD><TD>        pageSeparator = separator;</TD></TR><TR CLASS="z"><TD CLASS="l">1152</TD><TD>    }</TD></TR><TR><TD CLASS="l">1153</TD><TD> </TD></TR><TR><TD CLASS="l">1154</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1155</TD><TD>     * This will get the word separator.</TD></TR><TR><TD CLASS="l">1156</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="13">1157</A></TD><TD>     * @return The desired word separator string.</TD></TR><TR><TD CLASS="l">1158</TD><TD>     */</TD></TR><TR><TD CLASS="l">1159</TD><TD>    public String getWordSeparator()</TD></TR><TR><TD CLASS="l">1160</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1161</TD><TD>        return wordSeparator;</TD></TR><TR><TD CLASS="l">1162</TD><TD>    }</TD></TR><TR><TD CLASS="l">1163</TD><TD> </TD></TR><TR><TD CLASS="l">1164</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1165</TD><TD>     * Set the desired word separator for output text.  The PDFBox text extraction</TD></TR><TR><TD CLASS="l">1166</TD><TD>     * algorithm will output a space character if there is enough space between</TD></TR><TR><TD CLASS="l">1167</TD><TD>     * two words.  By default a space character is used.  If you need and accurate</TD></TR><TR><TD CLASS="l">1168</TD><TD>     * count of characters that are found in a PDF document then you might want to</TD></TR><TR><TD CLASS="l">1169</TD><TD>     * set the word separator to the empty string.</TD></TR><TR><TD CLASS="l">1170</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="1f">1171</A></TD><TD>     * @param separator The desired page separator string.</TD></TR><TR><TD CLASS="l">1172</TD><TD>     */</TD></TR><TR><TD CLASS="l">1173</TD><TD>    public void setWordSeparator(String separator)</TD></TR><TR><TD CLASS="l">1174</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1175</TD><TD>        wordSeparator = separator;</TD></TR><TR CLASS="z"><TD CLASS="l">1176</TD><TD>    }</TD></TR><TR><TD CLASS="l">1177</TD><TD> </TD></TR><TR><TD CLASS="l">1178</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1179</TD><TD>     * This will get the page separator.</TD></TR><TR><TD CLASS="l">1180</TD><TD>     *</TD></TR><TR><TD CLASS="l">1181</TD><TD>     * @return The page separator string.</TD></TR><TR><TD CLASS="l">1182</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="d">1183</A></TD><TD>     * @deprecated use {@link #getPageStart()} and {@link #getPageEnd()} instead</TD></TR><TR><TD CLASS="l">1184</TD><TD>     */</TD></TR><TR><TD CLASS="l">1185</TD><TD>    public String getPageSeparator()</TD></TR><TR><TD CLASS="l">1186</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1187</TD><TD>        return pageSeparator;</TD></TR><TR><TD CLASS="l">1188</TD><TD>    }</TD></TR><TR><TD CLASS="l">1189</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="11">1190</A></TD><TD>     * @return Returns the suppressDuplicateOverlappingText.</TD></TR><TR><TD CLASS="l">1191</TD><TD>     */</TD></TR><TR><TD CLASS="l">1192</TD><TD>    public boolean getSuppressDuplicateOverlappingText()</TD></TR><TR><TD CLASS="l">1193</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1194</TD><TD>        return suppressDuplicateOverlappingText;</TD></TR><TR><TD CLASS="l">1195</TD><TD>    }</TD></TR><TR><TD CLASS="l">1196</TD><TD> </TD></TR><TR><TD CLASS="l">1197</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1198</TD><TD>     * Get the current page number that is being processed.</TD></TR><TR><TD CLASS="l">1199</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="8">1200</A></TD><TD>     * @return A 1 based number representing the current page.</TD></TR><TR><TD CLASS="l">1201</TD><TD>     */</TD></TR><TR><TD CLASS="l">1202</TD><TD>    protected int getCurrentPageNo()</TD></TR><TR><TD CLASS="l">1203</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1204</TD><TD>        return currentPageNo;</TD></TR><TR><TD CLASS="l">1205</TD><TD>    }</TD></TR><TR><TD CLASS="l">1206</TD><TD> </TD></TR><TR><TD CLASS="l">1207</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1208</TD><TD>     * The output stream that is being written to.</TD></TR><TR><TD CLASS="l">1209</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="b">1210</A></TD><TD>     * @return The stream that output is being written to.</TD></TR><TR><TD CLASS="l">1211</TD><TD>     */</TD></TR><TR><TD CLASS="l">1212</TD><TD>    protected Writer getOutput()</TD></TR><TR><TD CLASS="l">1213</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1214</TD><TD>        return output;</TD></TR><TR><TD CLASS="l">1215</TD><TD>    }</TD></TR><TR><TD CLASS="l">1216</TD><TD> </TD></TR><TR><TD CLASS="l">1217</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1218</TD><TD>     * Character strings are grouped by articles.  It is quite common that there</TD></TR><TR><TD CLASS="l">1219</TD><TD>     * will only be a single article.  This returns a List that contains List objects,</TD></TR><TR><TD CLASS="l">1220</TD><TD>     * the inner lists will contain TextPosition objects.</TD></TR><TR><TD CLASS="l">1221</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="7">1222</A></TD><TD>     * @return A double List of TextPositions for all text strings on the page.</TD></TR><TR><TD CLASS="l">1223</TD><TD>     */</TD></TR><TR><TD CLASS="l">1224</TD><TD>    protected Vector&lt;List&lt;TextPosition&gt;&gt; getCharactersByArticle()</TD></TR><TR><TD CLASS="l">1225</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1226</TD><TD>        return charactersByArticle;</TD></TR><TR><TD CLASS="l">1227</TD><TD>    }</TD></TR><TR><TD CLASS="l">1228</TD><TD> </TD></TR><TR><TD CLASS="l">1229</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1230</TD><TD>     * By default the text stripper will attempt to remove text that overlapps each other.</TD></TR><TR><TD CLASS="l">1231</TD><TD>     * Word paints the same character several times in order to make it look bold.  By setting</TD></TR><TR><TD CLASS="l">1232</TD><TD>     * this to false all text will be extracted, which means that certain sections will be</TD></TR><TR><TD CLASS="l">1233</TD><TD>     * duplicated, but better performance will be noticed.</TD></TR><TR><TD CLASS="l">1234</TD><TD>     *</TD></TR><TR><TD CLASS="l">1235</TD><TD>     * @param suppressDuplicateOverlappingTextValue The suppressDuplicateOverlappingText to set.</TD></TR><TR><TD CLASS="l"><A NAME="1e">1236</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1237</TD><TD>    public void setSuppressDuplicateOverlappingText(</TD></TR><TR><TD CLASS="l">1238</TD><TD>            boolean suppressDuplicateOverlappingTextValue)</TD></TR><TR><TD CLASS="l">1239</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1240</TD><TD>        suppressDuplicateOverlappingText = suppressDuplicateOverlappingTextValue;</TD></TR><TR CLASS="z"><TD CLASS="l">1241</TD><TD>    }</TD></TR><TR><TD CLASS="l">1242</TD><TD> </TD></TR><TR><TD CLASS="l">1243</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1244</TD><TD>     * This will tell if the text stripper should separate by beads.</TD></TR><TR><TD CLASS="l">1245</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="e">1246</A></TD><TD>     * @return If the text will be grouped by beads.</TD></TR><TR><TD CLASS="l">1247</TD><TD>     */</TD></TR><TR><TD CLASS="l">1248</TD><TD>    public boolean getSeparateByBeads()</TD></TR><TR><TD CLASS="l">1249</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1250</TD><TD>        return shouldSeparateByBeads;</TD></TR><TR><TD CLASS="l">1251</TD><TD>    }</TD></TR><TR><TD CLASS="l">1252</TD><TD> </TD></TR><TR><TD CLASS="l">1253</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1254</TD><TD>     * Set if the text stripper should group the text output by a list of beads.  The default value is true!</TD></TR><TR><TD CLASS="l">1255</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="53">1256</A></TD><TD>     * @param aShouldSeparateByBeads The new grouping of beads.</TD></TR><TR><TD CLASS="l">1257</TD><TD>     */</TD></TR><TR><TD CLASS="l">1258</TD><TD>    public void setShouldSeparateByBeads(boolean aShouldSeparateByBeads)</TD></TR><TR><TD CLASS="l">1259</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1260</TD><TD>        shouldSeparateByBeads = aShouldSeparateByBeads;</TD></TR><TR CLASS="c"><TD CLASS="l">1261</TD><TD>    }</TD></TR><TR><TD CLASS="l">1262</TD><TD> </TD></TR><TR><TD CLASS="l">1263</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1264</TD><TD>     * Get the bookmark where text extraction should end, inclusive.  Default is null.</TD></TR><TR><TD CLASS="l">1265</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="9">1266</A></TD><TD>     * @return The ending bookmark.</TD></TR><TR><TD CLASS="l">1267</TD><TD>     */</TD></TR><TR><TD CLASS="l">1268</TD><TD>    public PDOutlineItem getEndBookmark()</TD></TR><TR><TD CLASS="l">1269</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1270</TD><TD>        return endBookmark;</TD></TR><TR><TD CLASS="l">1271</TD><TD>    }</TD></TR><TR><TD CLASS="l">1272</TD><TD> </TD></TR><TR><TD CLASS="l">1273</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1274</TD><TD>     * Set the bookmark where the text extraction should stop.</TD></TR><TR><TD CLASS="l">1275</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="18">1276</A></TD><TD>     * @param aEndBookmark The ending bookmark.</TD></TR><TR><TD CLASS="l">1277</TD><TD>     */</TD></TR><TR><TD CLASS="l">1278</TD><TD>    public void setEndBookmark(PDOutlineItem aEndBookmark)</TD></TR><TR><TD CLASS="l">1279</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1280</TD><TD>        endBookmark = aEndBookmark;</TD></TR><TR CLASS="z"><TD CLASS="l">1281</TD><TD>    }</TD></TR><TR><TD CLASS="l">1282</TD><TD> </TD></TR><TR><TD CLASS="l">1283</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1284</TD><TD>     * Get the bookmark where text extraction should start, inclusive.  Default is null.</TD></TR><TR><TD CLASS="l">1285</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="f">1286</A></TD><TD>     * @return The starting bookmark.</TD></TR><TR><TD CLASS="l">1287</TD><TD>     */</TD></TR><TR><TD CLASS="l">1288</TD><TD>    public PDOutlineItem getStartBookmark()</TD></TR><TR><TD CLASS="l">1289</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1290</TD><TD>        return startBookmark;</TD></TR><TR><TD CLASS="l">1291</TD><TD>    }</TD></TR><TR><TD CLASS="l">1292</TD><TD> </TD></TR><TR><TD CLASS="l">1293</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1294</TD><TD>     * Set the bookmark where text extraction should start, inclusive.</TD></TR><TR><TD CLASS="l">1295</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="1d">1296</A></TD><TD>     * @param aStartBookmark The starting bookmark.</TD></TR><TR><TD CLASS="l">1297</TD><TD>     */</TD></TR><TR><TD CLASS="l">1298</TD><TD>    public void setStartBookmark(PDOutlineItem aStartBookmark)</TD></TR><TR><TD CLASS="l">1299</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1300</TD><TD>        startBookmark = aStartBookmark;</TD></TR><TR CLASS="z"><TD CLASS="l">1301</TD><TD>    }</TD></TR><TR><TD CLASS="l">1302</TD><TD> </TD></TR><TR><TD CLASS="l">1303</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1304</TD><TD>     * This will tell if the text stripper should add some more text formatting.</TD></TR><TR><TD CLASS="l"><A NAME="39">1305</A></TD><TD>     * @return true if some more text formatting will be added</TD></TR><TR><TD CLASS="l">1306</TD><TD>     */</TD></TR><TR><TD CLASS="l">1307</TD><TD>    public boolean getAddMoreFormatting()</TD></TR><TR><TD CLASS="l">1308</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1309</TD><TD>        return addMoreFormatting;</TD></TR><TR><TD CLASS="l">1310</TD><TD>    }</TD></TR><TR><TD CLASS="l">1311</TD><TD>    </TD></TR><TR><TD CLASS="l">1312</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1313</TD><TD>     * There will some additional text formatting be added if addMoreFormatting</TD></TR><TR><TD CLASS="l">1314</TD><TD>     * is set to true. Default is false. </TD></TR><TR><TD CLASS="l"><A NAME="15">1315</A></TD><TD>     * @param newAddMoreFormatting Tell PDFBox to add some more text formatting</TD></TR><TR><TD CLASS="l">1316</TD><TD>     */</TD></TR><TR><TD CLASS="l">1317</TD><TD>    public void setAddMoreFormatting(boolean newAddMoreFormatting)</TD></TR><TR><TD CLASS="l">1318</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1319</TD><TD>        addMoreFormatting = newAddMoreFormatting;</TD></TR><TR CLASS="z"><TD CLASS="l">1320</TD><TD>    }</TD></TR><TR><TD CLASS="l">1321</TD><TD> </TD></TR><TR><TD CLASS="l">1322</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1323</TD><TD>     * This will tell if the text stripper should sort the text tokens</TD></TR><TR><TD CLASS="l">1324</TD><TD>     * before writing to the stream.</TD></TR><TR><TD CLASS="l">1325</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="45">1326</A></TD><TD>     * @return true If the text tokens will be sorted before being written.</TD></TR><TR><TD CLASS="l">1327</TD><TD>     */</TD></TR><TR><TD CLASS="l">1328</TD><TD>    public boolean getSortByPosition()</TD></TR><TR><TD CLASS="l">1329</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1330</TD><TD>        return sortByPosition;</TD></TR><TR><TD CLASS="l">1331</TD><TD>    }</TD></TR><TR><TD CLASS="l">1332</TD><TD> </TD></TR><TR><TD CLASS="l">1333</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1334</TD><TD>     * The order of the text tokens in a PDF file may not be in the same</TD></TR><TR><TD CLASS="l">1335</TD><TD>     * as they appear visually on the screen.  For example, a PDF writer may</TD></TR><TR><TD CLASS="l">1336</TD><TD>     * write out all text by font, so all bold or larger text, then make a second</TD></TR><TR><TD CLASS="l">1337</TD><TD>     * pass and write out the normal text.&lt;br/&gt;</TD></TR><TR><TD CLASS="l">1338</TD><TD>     * The default is to &lt;b&gt;not&lt;/b&gt; sort by position.&lt;br/&gt;</TD></TR><TR><TD CLASS="l">1339</TD><TD>     * &lt;br/&gt;</TD></TR><TR><TD CLASS="l">1340</TD><TD>     * A PDF writer could choose to write each character in a different order.  By</TD></TR><TR><TD CLASS="l">1341</TD><TD>     * default PDFBox does &lt;b&gt;not&lt;/b&gt; sort the text tokens before processing them due to</TD></TR><TR><TD CLASS="l">1342</TD><TD>     * performance reasons.</TD></TR><TR><TD CLASS="l">1343</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="54">1344</A></TD><TD>     * @param newSortByPosition Tell PDFBox to sort the text positions.</TD></TR><TR><TD CLASS="l">1345</TD><TD>     */</TD></TR><TR><TD CLASS="l">1346</TD><TD>    public void setSortByPosition(boolean newSortByPosition)</TD></TR><TR><TD CLASS="l">1347</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1348</TD><TD>        sortByPosition = newSortByPosition;</TD></TR><TR CLASS="c"><TD CLASS="l">1349</TD><TD>    }</TD></TR><TR><TD CLASS="l">1350</TD><TD> </TD></TR><TR><TD CLASS="l">1351</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1352</TD><TD>     * Get the current space width-based tolerance value that is being used</TD></TR><TR><TD CLASS="l">1353</TD><TD>     * to estimate where spaces in text should be added.  Note that the</TD></TR><TR><TD CLASS="l">1354</TD><TD>     * default value for this has been determined from trial and error. </TD></TR><TR><TD CLASS="l">1355</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="46">1356</A></TD><TD>     * @return The current tolerance / scaling factor</TD></TR><TR><TD CLASS="l">1357</TD><TD>     */</TD></TR><TR><TD CLASS="l">1358</TD><TD>    public float getSpacingTolerance() </TD></TR><TR><TD CLASS="l">1359</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1360</TD><TD>        return spacingTolerance;</TD></TR><TR><TD CLASS="l">1361</TD><TD>    }</TD></TR><TR><TD CLASS="l">1362</TD><TD> </TD></TR><TR><TD CLASS="l">1363</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1364</TD><TD>     * Set the space width-based tolerance value that is used</TD></TR><TR><TD CLASS="l">1365</TD><TD>     * to estimate where spaces in text should be added.  Note that the</TD></TR><TR><TD CLASS="l">1366</TD><TD>     * default value for this has been determined from trial and error.</TD></TR><TR><TD CLASS="l">1367</TD><TD>     * Setting this value larger will reduce the number of spaces added. </TD></TR><TR><TD CLASS="l">1368</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="1c">1369</A></TD><TD>     * @param spacingToleranceValue tolerance / scaling factor to use</TD></TR><TR><TD CLASS="l">1370</TD><TD>     */</TD></TR><TR><TD CLASS="l">1371</TD><TD>    public void setSpacingTolerance(float spacingToleranceValue)</TD></TR><TR><TD CLASS="l">1372</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1373</TD><TD>        spacingTolerance = spacingToleranceValue;</TD></TR><TR CLASS="z"><TD CLASS="l">1374</TD><TD>    }</TD></TR><TR><TD CLASS="l">1375</TD><TD> </TD></TR><TR><TD CLASS="l">1376</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1377</TD><TD>     * Get the current character width-based tolerance value that is being used</TD></TR><TR><TD CLASS="l">1378</TD><TD>     * to estimate where spaces in text should be added.  Note that the</TD></TR><TR><TD CLASS="l">1379</TD><TD>     * default value for this has been determined from trial and error.</TD></TR><TR><TD CLASS="l">1380</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="3c">1381</A></TD><TD>     * @return The current tolerance / scaling factor</TD></TR><TR><TD CLASS="l">1382</TD><TD>     */</TD></TR><TR><TD CLASS="l">1383</TD><TD>    public float getAverageCharTolerance() </TD></TR><TR><TD CLASS="l">1384</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1385</TD><TD>        return averageCharTolerance;</TD></TR><TR><TD CLASS="l">1386</TD><TD>    }</TD></TR><TR><TD CLASS="l">1387</TD><TD> </TD></TR><TR><TD CLASS="l">1388</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1389</TD><TD>     * Set the character width-based tolerance value that is used</TD></TR><TR><TD CLASS="l">1390</TD><TD>     * to estimate where spaces in text should be added.  Note that the</TD></TR><TR><TD CLASS="l">1391</TD><TD>     * default value for this has been determined from trial and error.</TD></TR><TR><TD CLASS="l">1392</TD><TD>     * Setting this value larger will reduce the number of spaces added. </TD></TR><TR><TD CLASS="l">1393</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="16">1394</A></TD><TD>     * @param averageCharToleranceValue average tolerance / scaling factor to use</TD></TR><TR><TD CLASS="l">1395</TD><TD>     */</TD></TR><TR><TD CLASS="l">1396</TD><TD>    public void setAverageCharTolerance(float averageCharToleranceValue) </TD></TR><TR><TD CLASS="l">1397</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1398</TD><TD>        averageCharTolerance = averageCharToleranceValue;</TD></TR><TR CLASS="z"><TD CLASS="l">1399</TD><TD>    }</TD></TR><TR><TD CLASS="l">1400</TD><TD> </TD></TR><TR><TD CLASS="l">1401</TD><TD> </TD></TR><TR><TD CLASS="l">1402</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1403</TD><TD>     * returns the multiple of whitespace character widths</TD></TR><TR><TD CLASS="l">1404</TD><TD>     * for the current text which the current</TD></TR><TR><TD CLASS="l">1405</TD><TD>     * line start can be indented from the previous line start</TD></TR><TR><TD CLASS="l">1406</TD><TD>     * beyond which the current line start is considered</TD></TR><TR><TD CLASS="l">1407</TD><TD>     * to be a paragraph start.</TD></TR><TR><TD CLASS="l">1408</TD><TD>     * @return the number of whitespace character widths to use</TD></TR><TR><TD CLASS="l"><A NAME="3e">1409</A></TD><TD>     * when detecting paragraph indents.</TD></TR><TR><TD CLASS="l">1410</TD><TD>     */</TD></TR><TR><TD CLASS="l">1411</TD><TD>    public float getIndentThreshold() </TD></TR><TR><TD CLASS="l">1412</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1413</TD><TD>        return indentThreshold;</TD></TR><TR><TD CLASS="l">1414</TD><TD>    }</TD></TR><TR><TD CLASS="l">1415</TD><TD> </TD></TR><TR><TD CLASS="l">1416</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1417</TD><TD>     * sets the multiple of whitespace character widths</TD></TR><TR><TD CLASS="l">1418</TD><TD>     * for the current text which the current</TD></TR><TR><TD CLASS="l">1419</TD><TD>     * line start can be indented from the previous line start</TD></TR><TR><TD CLASS="l">1420</TD><TD>     * beyond which the current line start is considered</TD></TR><TR><TD CLASS="l">1421</TD><TD>     * to be a paragraph start.  The default value is 2.0.</TD></TR><TR><TD CLASS="l">1422</TD><TD>     *</TD></TR><TR><TD CLASS="l">1423</TD><TD>     * @param indentThresholdValue the number of whitespace character widths to use</TD></TR><TR><TD CLASS="l"><A NAME="19">1424</A></TD><TD>     * when detecting paragraph indents.</TD></TR><TR><TD CLASS="l">1425</TD><TD>     */</TD></TR><TR><TD CLASS="l">1426</TD><TD>    public void setIndentThreshold(float indentThresholdValue) </TD></TR><TR><TD CLASS="l">1427</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1428</TD><TD>        indentThreshold = indentThresholdValue;</TD></TR><TR CLASS="z"><TD CLASS="l">1429</TD><TD>    }</TD></TR><TR><TD CLASS="l">1430</TD><TD> </TD></TR><TR><TD CLASS="l">1431</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1432</TD><TD>     * the minimum whitespace, as a multiple</TD></TR><TR><TD CLASS="l">1433</TD><TD>     * of the max height of the current characters</TD></TR><TR><TD CLASS="l">1434</TD><TD>     * beyond which the current line start is considered</TD></TR><TR><TD CLASS="l">1435</TD><TD>     * to be a paragraph start.</TD></TR><TR><TD CLASS="l">1436</TD><TD>     * @return the character height multiple for</TD></TR><TR><TD CLASS="l">1437</TD><TD>     * max allowed whitespace between lines in</TD></TR><TR><TD CLASS="l"><A NAME="3d">1438</A></TD><TD>     * the same paragraph.</TD></TR><TR><TD CLASS="l">1439</TD><TD>     */</TD></TR><TR><TD CLASS="l">1440</TD><TD>    public float getDropThreshold() </TD></TR><TR><TD CLASS="l">1441</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1442</TD><TD>        return dropThreshold;</TD></TR><TR><TD CLASS="l">1443</TD><TD>    }</TD></TR><TR><TD CLASS="l">1444</TD><TD> </TD></TR><TR><TD CLASS="l">1445</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1446</TD><TD>     * sets the minimum whitespace, as a multiple</TD></TR><TR><TD CLASS="l">1447</TD><TD>     * of the max height of the current characters</TD></TR><TR><TD CLASS="l">1448</TD><TD>     * beyond which the current line start is considered</TD></TR><TR><TD CLASS="l">1449</TD><TD>     * to be a paragraph start.  The default value is 2.5.</TD></TR><TR><TD CLASS="l">1450</TD><TD>     *</TD></TR><TR><TD CLASS="l">1451</TD><TD>     * @param dropThresholdValue the character height multiple for</TD></TR><TR><TD CLASS="l">1452</TD><TD>     * max allowed whitespace between lines in</TD></TR><TR><TD CLASS="l"><A NAME="17">1453</A></TD><TD>     * the same paragraph.</TD></TR><TR><TD CLASS="l">1454</TD><TD>     */</TD></TR><TR><TD CLASS="l">1455</TD><TD>    public void setDropThreshold(float dropThresholdValue) </TD></TR><TR><TD CLASS="l">1456</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1457</TD><TD>        dropThreshold = dropThresholdValue;</TD></TR><TR CLASS="z"><TD CLASS="l">1458</TD><TD>    }</TD></TR><TR><TD CLASS="l">1459</TD><TD> </TD></TR><TR><TD CLASS="l">1460</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1461</TD><TD>     * Returns the string which will be used at the beginning of a paragraph.</TD></TR><TR><TD CLASS="l"><A NAME="44">1462</A></TD><TD>     * @return the paragraph start string</TD></TR><TR><TD CLASS="l">1463</TD><TD>     */</TD></TR><TR><TD CLASS="l">1464</TD><TD>    public String getParagraphStart()</TD></TR><TR><TD CLASS="l">1465</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1466</TD><TD>        return paragraphStart;</TD></TR><TR><TD CLASS="l">1467</TD><TD>    }</TD></TR><TR><TD CLASS="l">1468</TD><TD> </TD></TR><TR><TD CLASS="l">1469</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1470</TD><TD>     * Sets the string which will be used at the beginning of a paragraph.</TD></TR><TR><TD CLASS="l"><A NAME="52">1471</A></TD><TD>     * @param s the paragraph start string</TD></TR><TR><TD CLASS="l">1472</TD><TD>     */</TD></TR><TR><TD CLASS="l">1473</TD><TD>    public void setParagraphStart(String s)</TD></TR><TR><TD CLASS="l">1474</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1475</TD><TD>        paragraphStart = s;</TD></TR><TR CLASS="c"><TD CLASS="l">1476</TD><TD>    }</TD></TR><TR><TD CLASS="l">1477</TD><TD> </TD></TR><TR><TD CLASS="l">1478</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1479</TD><TD>     * Returns the string which will be used at the end of a paragraph.</TD></TR><TR><TD CLASS="l"><A NAME="43">1480</A></TD><TD>     * @return the paragraph end string</TD></TR><TR><TD CLASS="l">1481</TD><TD>     */</TD></TR><TR><TD CLASS="l">1482</TD><TD>    public String getParagraphEnd()</TD></TR><TR><TD CLASS="l">1483</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1484</TD><TD>        return paragraphEnd;</TD></TR><TR><TD CLASS="l">1485</TD><TD>    }</TD></TR><TR><TD CLASS="l">1486</TD><TD> </TD></TR><TR><TD CLASS="l">1487</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1488</TD><TD>     * Sets the string which will be used at the end of a paragraph.</TD></TR><TR><TD CLASS="l"><A NAME="51">1489</A></TD><TD>     * @param s the paragraph end string</TD></TR><TR><TD CLASS="l">1490</TD><TD>     */</TD></TR><TR><TD CLASS="l">1491</TD><TD>    public void setParagraphEnd(String s)</TD></TR><TR><TD CLASS="l">1492</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1493</TD><TD>        paragraphEnd = s;</TD></TR><TR CLASS="c"><TD CLASS="l">1494</TD><TD>    }</TD></TR><TR><TD CLASS="l">1495</TD><TD> </TD></TR><TR><TD CLASS="l">1496</TD><TD> </TD></TR><TR><TD CLASS="l">1497</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1498</TD><TD>     * Returns the string which will be used at the beginning of a page.</TD></TR><TR><TD CLASS="l"><A NAME="42">1499</A></TD><TD>     * @return the page start string</TD></TR><TR><TD CLASS="l">1500</TD><TD>     */</TD></TR><TR><TD CLASS="l">1501</TD><TD>    public String getPageStart() </TD></TR><TR><TD CLASS="l">1502</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1503</TD><TD>        return pageStart;</TD></TR><TR><TD CLASS="l">1504</TD><TD>    }</TD></TR><TR><TD CLASS="l">1505</TD><TD> </TD></TR><TR><TD CLASS="l">1506</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1507</TD><TD>     * Sets the string which will be used at the beginning of a page.</TD></TR><TR><TD CLASS="l"><A NAME="50">1508</A></TD><TD>     * @param pageStartValue the page start string</TD></TR><TR><TD CLASS="l">1509</TD><TD>     */</TD></TR><TR><TD CLASS="l">1510</TD><TD>    public void setPageStart(String pageStartValue) </TD></TR><TR><TD CLASS="l">1511</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1512</TD><TD>        pageStart = pageStartValue;</TD></TR><TR CLASS="c"><TD CLASS="l">1513</TD><TD>    }</TD></TR><TR><TD CLASS="l">1514</TD><TD> </TD></TR><TR><TD CLASS="l">1515</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1516</TD><TD>     * Returns the string which will be used at the end of a page.</TD></TR><TR><TD CLASS="l"><A NAME="41">1517</A></TD><TD>     * @return the page end string</TD></TR><TR><TD CLASS="l">1518</TD><TD>     */</TD></TR><TR><TD CLASS="l">1519</TD><TD>    public String getPageEnd() </TD></TR><TR><TD CLASS="l">1520</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1521</TD><TD>        return pageEnd;</TD></TR><TR><TD CLASS="l">1522</TD><TD>    }</TD></TR><TR><TD CLASS="l">1523</TD><TD> </TD></TR><TR><TD CLASS="l">1524</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1525</TD><TD>     * Sets the string which will be used at the end of a page.</TD></TR><TR><TD CLASS="l"><A NAME="4f">1526</A></TD><TD>     * @param pageEndValue the page end string</TD></TR><TR><TD CLASS="l">1527</TD><TD>     */</TD></TR><TR><TD CLASS="l">1528</TD><TD>    public void setPageEnd(String pageEndValue) </TD></TR><TR><TD CLASS="l">1529</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1530</TD><TD>        pageEnd = pageEndValue;</TD></TR><TR CLASS="c"><TD CLASS="l">1531</TD><TD>    }</TD></TR><TR><TD CLASS="l">1532</TD><TD> </TD></TR><TR><TD CLASS="l">1533</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1534</TD><TD>     * Returns the string which will be used at the beginning of an article.</TD></TR><TR><TD CLASS="l"><A NAME="3b">1535</A></TD><TD>     * @return the article start string</TD></TR><TR><TD CLASS="l">1536</TD><TD>     */</TD></TR><TR><TD CLASS="l">1537</TD><TD>    public String getArticleStart() </TD></TR><TR><TD CLASS="l">1538</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1539</TD><TD>        return articleStart;</TD></TR><TR><TD CLASS="l">1540</TD><TD>    }</TD></TR><TR><TD CLASS="l">1541</TD><TD> </TD></TR><TR><TD CLASS="l">1542</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1543</TD><TD>     * Sets the string which will be used at the beginning of an article.</TD></TR><TR><TD CLASS="l"><A NAME="4c">1544</A></TD><TD>     * @param articleStartValue the article start string</TD></TR><TR><TD CLASS="l">1545</TD><TD>     */</TD></TR><TR><TD CLASS="l">1546</TD><TD>    public void setArticleStart(String articleStartValue) </TD></TR><TR><TD CLASS="l">1547</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1548</TD><TD>        articleStart = articleStartValue;</TD></TR><TR CLASS="c"><TD CLASS="l">1549</TD><TD>    }</TD></TR><TR><TD CLASS="l">1550</TD><TD> </TD></TR><TR><TD CLASS="l">1551</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1552</TD><TD>     * Returns the string which will be used at the end of an article.</TD></TR><TR><TD CLASS="l"><A NAME="3a">1553</A></TD><TD>     * @return the article end string</TD></TR><TR><TD CLASS="l">1554</TD><TD>     */</TD></TR><TR><TD CLASS="l">1555</TD><TD>    public String getArticleEnd()</TD></TR><TR><TD CLASS="l">1556</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1557</TD><TD>        return articleEnd;</TD></TR><TR><TD CLASS="l">1558</TD><TD>    }</TD></TR><TR><TD CLASS="l">1559</TD><TD> </TD></TR><TR><TD CLASS="l">1560</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1561</TD><TD>     * Sets the string which will be used at the end of an article.</TD></TR><TR><TD CLASS="l"><A NAME="4b">1562</A></TD><TD>     * @param articleEndValue the article end string</TD></TR><TR><TD CLASS="l">1563</TD><TD>     */</TD></TR><TR><TD CLASS="l">1564</TD><TD>    public void setArticleEnd(String articleEndValue)</TD></TR><TR><TD CLASS="l">1565</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1566</TD><TD>        articleEnd = articleEndValue;</TD></TR><TR CLASS="c"><TD CLASS="l">1567</TD><TD>    }</TD></TR><TR><TD CLASS="l">1568</TD><TD> </TD></TR><TR><TD CLASS="l">1569</TD><TD> </TD></TR><TR><TD CLASS="l">1570</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1571</TD><TD>     * Reverse characters of a compound Arabic glyph.</TD></TR><TR><TD CLASS="l">1572</TD><TD>     * When getSortByPosition() is true, inspect the sequence encoded</TD></TR><TR><TD CLASS="l">1573</TD><TD>     * by one glyph. If the glyph encodes two or more Arabic characters,</TD></TR><TR><TD CLASS="l">1574</TD><TD>     * reverse these characters from a logical order to a visual order.</TD></TR><TR><TD CLASS="l">1575</TD><TD>     * This ensures that the bidirectional algorithm that runs later will</TD></TR><TR><TD CLASS="l">1576</TD><TD>     * convert them back to a logical order.</TD></TR><TR><TD CLASS="l">1577</TD><TD>     * </TD></TR><TR><TD CLASS="l">1578</TD><TD>     * @param str a string obtained from font.encoding()</TD></TR><TR><TD CLASS="l">1579</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="14">1580</A></TD><TD>     * @return the reversed string</TD></TR><TR><TD CLASS="l">1581</TD><TD>     */</TD></TR><TR><TD CLASS="l">1582</TD><TD>    public String inspectFontEncoding(String str)</TD></TR><TR><TD CLASS="l">1583</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1584</TD><TD>        if (!sortByPosition || str == null || str.length() &lt; 2)</TD></TR><TR><TD CLASS="l">1585</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1586</TD><TD>            return str;</TD></TR><TR><TD CLASS="l">1587</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1588</TD><TD>        for (int i = 0; i &lt; str.length(); ++i)</TD></TR><TR><TD CLASS="l">1589</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1590</TD><TD>            if (Character.getDirectionality(str.charAt(i))</TD></TR><TR><TD CLASS="l">1591</TD><TD>                    != Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC)</TD></TR><TR><TD CLASS="l">1592</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1593</TD><TD>                return str;</TD></TR><TR><TD CLASS="l">1594</TD><TD>            }</TD></TR><TR><TD CLASS="l">1595</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1596</TD><TD>        StringBuilder reversed = new StringBuilder(str.length());</TD></TR><TR CLASS="z"><TD CLASS="l">1597</TD><TD>        for (int i = str.length() - 1; i &gt;= 0; --i)</TD></TR><TR><TD CLASS="l">1598</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1599</TD><TD>            reversed.append(str.charAt(i));</TD></TR><TR><TD CLASS="l">1600</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">1601</TD><TD>        return reversed.toString();</TD></TR><TR><TD CLASS="l">1602</TD><TD>    }</TD></TR><TR><TD CLASS="l">1603</TD><TD> </TD></TR><TR><TD CLASS="l">1604</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1605</TD><TD>     * handles the line separator for a new line given</TD></TR><TR><TD CLASS="l">1606</TD><TD>     * the specified current and previous TextPositions.</TD></TR><TR><TD CLASS="l">1607</TD><TD>     * @param current the current text position</TD></TR><TR><TD CLASS="l">1608</TD><TD>     * @param lastPosition the previous text position</TD></TR><TR><TD CLASS="l">1609</TD><TD>     * @param lastLineStartPosition the last text position that followed a line</TD></TR><TR><TD CLASS="l">1610</TD><TD>     *        separator.</TD></TR><TR><TD CLASS="l">1611</TD><TD>     * @param maxHeightForLine max height for positions since lastLineStartPosition</TD></TR><TR><TD CLASS="l">1612</TD><TD>     * @return start position of the last line</TD></TR><TR><TD CLASS="l">1613</TD><TD>     * @throws IOException if something went wrong</TD></TR><TR><TD CLASS="l">1614</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="30">1615</A></TD><TD>    protected PositionWrapper handleLineSeparation(PositionWrapper current,</TD></TR><TR><TD CLASS="l">1616</TD><TD>            PositionWrapper lastPosition, PositionWrapper lastLineStartPosition, float maxHeightForLine)</TD></TR><TR><TD CLASS="l">1617</TD><TD>            throws IOException </TD></TR><TR><TD CLASS="l">1618</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">1619</TD><TD>        current.setLineStart();</TD></TR><TR CLASS="c"><TD CLASS="l">1620</TD><TD>        isParagraphSeparation(current, lastPosition, lastLineStartPosition, maxHeightForLine);</TD></TR><TR CLASS="c"><TD CLASS="l">1621</TD><TD>        lastLineStartPosition = current;</TD></TR><TR CLASS="c"><TD CLASS="l">1622</TD><TD>        if (current.isParagraphStart())  </TD></TR><TR><TD CLASS="l">1623</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1624</TD><TD>            if(lastPosition.isArticleStart()) </TD></TR><TR><TD CLASS="l">1625</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1626</TD><TD>                writeParagraphStart();</TD></TR><TR><TD CLASS="l">1627</TD><TD>            } </TD></TR><TR><TD CLASS="l">1628</TD><TD>            else </TD></TR><TR><TD CLASS="l">1629</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">1630</TD><TD>                writeLineSeparator();</TD></TR><TR CLASS="c"><TD CLASS="l">1631</TD><TD>                writeParagraphSeparator();</TD></TR><TR><TD CLASS="l">1632</TD><TD>            }</TD></TR><TR><TD CLASS="l">1633</TD><TD>        } </TD></TR><TR><TD CLASS="l">1634</TD><TD>        else </TD></TR><TR><TD CLASS="l">1635</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1636</TD><TD>            writeLineSeparator();</TD></TR><TR><TD CLASS="l">1637</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1638</TD><TD>        return lastLineStartPosition;</TD></TR><TR><TD CLASS="l">1639</TD><TD>    }</TD></TR><TR><TD CLASS="l">1640</TD><TD>    </TD></TR><TR><TD CLASS="l">1641</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1642</TD><TD>     * tests the relationship between the last text position, the current text</TD></TR><TR><TD CLASS="l">1643</TD><TD>     * position and the last text position that followed a line separator to</TD></TR><TR><TD CLASS="l">1644</TD><TD>     * decide if the gap represents a paragraph separation. This should</TD></TR><TR><TD CLASS="l">1645</TD><TD>     * &lt;i&gt;only&lt;/i&gt; be called for consecutive text positions that first pass the</TD></TR><TR><TD CLASS="l">1646</TD><TD>     * line separation test.</TD></TR><TR><TD CLASS="l">1647</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1648</TD><TD>     * This base implementation tests to see if the lastLineStartPosition is</TD></TR><TR><TD CLASS="l">1649</TD><TD>     * null OR if the current vertical position has dropped below the last text</TD></TR><TR><TD CLASS="l">1650</TD><TD>     * vertical position by at least 2.5 times the current text height OR if the</TD></TR><TR><TD CLASS="l">1651</TD><TD>     * current horizontal position is indented by at least 2 times the current</TD></TR><TR><TD CLASS="l">1652</TD><TD>     * width of a space character.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">1653</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1654</TD><TD>     * This also attempts to identify text that is indented under a hanging indent.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">1655</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1656</TD><TD>     * This method sets the isParagraphStart and isHangingIndent flags on the current</TD></TR><TR><TD CLASS="l">1657</TD><TD>     * position object.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">1658</TD><TD>     *</TD></TR><TR><TD CLASS="l">1659</TD><TD>     * @param position the current text position.  This may have its isParagraphStart</TD></TR><TR><TD CLASS="l">1660</TD><TD>     * or isHangingIndent flags set upon return.</TD></TR><TR><TD CLASS="l">1661</TD><TD>     * @param lastPosition the previous text position (should not be null).</TD></TR><TR><TD CLASS="l">1662</TD><TD>     * @param lastLineStartPosition the last text position that followed a line</TD></TR><TR><TD CLASS="l">1663</TD><TD>     *            separator. May be null.</TD></TR><TR><TD CLASS="l">1664</TD><TD>     * @param maxHeightForLine max height for text positions since lasLineStartPosition.</TD></TR><TR><TD CLASS="l"><A NAME="2d">1665</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1666</TD><TD>    protected void isParagraphSeparation(PositionWrapper position,  </TD></TR><TR><TD CLASS="l">1667</TD><TD>            PositionWrapper lastPosition, PositionWrapper lastLineStartPosition, float maxHeightForLine)</TD></TR><TR><TD CLASS="l">1668</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1669</TD><TD>        boolean result = false;</TD></TR><TR CLASS="c"><TD CLASS="l">1670</TD><TD>        if(lastLineStartPosition == null) </TD></TR><TR><TD CLASS="l">1671</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1672</TD><TD>            result = true;</TD></TR><TR><TD CLASS="l">1673</TD><TD>        }</TD></TR><TR><TD CLASS="l">1674</TD><TD>        else</TD></TR><TR><TD CLASS="l">1675</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1676</TD><TD>            float yGap = Math.abs(position.getTextPosition().getYDirAdj()-</TD></TR><TR CLASS="c"><TD CLASS="l">1677</TD><TD>                    lastPosition.getTextPosition().getYDirAdj());</TD></TR><TR CLASS="c"><TD CLASS="l">1678</TD><TD>            float newYVal = multiplyFloat(getDropThreshold(), maxHeightForLine);</TD></TR><TR><TD CLASS="l">1679</TD><TD>            // do we need to flip this for rtl?</TD></TR><TR CLASS="c"><TD CLASS="l">1680</TD><TD>            float xGap = position.getTextPosition().getXDirAdj() -</TD></TR><TR CLASS="c"><TD CLASS="l">1681</TD><TD>                    lastLineStartPosition.getTextPosition().getXDirAdj();</TD></TR><TR CLASS="c"><TD CLASS="l">1682</TD><TD>            float newXVal = multiplyFloat(getIndentThreshold(), position.getTextPosition().getWidthOfSpace());</TD></TR><TR CLASS="c"><TD CLASS="l">1683</TD><TD>            float positionWidth = multiplyFloat(0.25f, position.getTextPosition().getWidth());</TD></TR><TR><TD CLASS="l">1684</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">1685</TD><TD>            if (yGap &gt; newYVal)</TD></TR><TR><TD CLASS="l">1686</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">1687</TD><TD>                result = true;</TD></TR><TR><TD CLASS="l">1688</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1689</TD><TD>            else if (xGap &gt; newXVal)</TD></TR><TR><TD CLASS="l">1690</TD><TD>            {</TD></TR><TR><TD CLASS="l">1691</TD><TD>                //text is indented, but try to screen for hanging indent</TD></TR><TR CLASS="c"><TD CLASS="l">1692</TD><TD>                if(!lastLineStartPosition.isParagraphStart())</TD></TR><TR><TD CLASS="l">1693</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1694</TD><TD>                     result = true;</TD></TR><TR><TD CLASS="l">1695</TD><TD>                }</TD></TR><TR><TD CLASS="l">1696</TD><TD>                else</TD></TR><TR><TD CLASS="l">1697</TD><TD>                {</TD></TR><TR CLASS="c"><TD CLASS="l">1698</TD><TD>                     position.setHangingIndent();</TD></TR><TR><TD CLASS="l">1699</TD><TD>                }</TD></TR><TR><TD CLASS="l">1700</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1701</TD><TD>            else if(xGap &lt; -position.getTextPosition().getWidthOfSpace())</TD></TR><TR><TD CLASS="l">1702</TD><TD>            {</TD></TR><TR><TD CLASS="l">1703</TD><TD>                //text is left of previous line. Was it a hanging indent?</TD></TR><TR CLASS="c"><TD CLASS="l">1704</TD><TD>                if(!lastLineStartPosition.isParagraphStart())</TD></TR><TR><TD CLASS="l">1705</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1706</TD><TD>                            result = true;</TD></TR><TR><TD CLASS="l">1707</TD><TD>                }</TD></TR><TR><TD CLASS="l">1708</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1709</TD><TD>            else if (Math.abs(xGap) &lt; positionWidth)</TD></TR><TR><TD CLASS="l">1710</TD><TD>            {</TD></TR><TR><TD CLASS="l">1711</TD><TD>                //current horizontal position is within 1/4 a char of the last</TD></TR><TR><TD CLASS="l">1712</TD><TD>                //linestart.  We'll treat them as lined up.</TD></TR><TR CLASS="c"><TD CLASS="l">1713</TD><TD>                if(lastLineStartPosition.isHangingIndent())</TD></TR><TR><TD CLASS="l">1714</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">1715</TD><TD>                    position.setHangingIndent();</TD></TR><TR><TD CLASS="l">1716</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">1717</TD><TD>                else if(lastLineStartPosition.isParagraphStart())</TD></TR><TR><TD CLASS="l">1718</TD><TD>                {</TD></TR><TR><TD CLASS="l">1719</TD><TD>                    //check to see if the previous line looks like</TD></TR><TR><TD CLASS="l">1720</TD><TD>                    //any of a number of standard list item formats</TD></TR><TR CLASS="c"><TD CLASS="l">1721</TD><TD>                    Pattern liPattern = matchListItemPattern(lastLineStartPosition);</TD></TR><TR CLASS="c"><TD CLASS="l">1722</TD><TD>                    if(liPattern!=null)</TD></TR><TR><TD CLASS="l">1723</TD><TD>                    {</TD></TR><TR CLASS="z"><TD CLASS="l">1724</TD><TD>                        Pattern currentPattern = matchListItemPattern(position);</TD></TR><TR CLASS="z"><TD CLASS="l">1725</TD><TD>                        if(liPattern == currentPattern)</TD></TR><TR><TD CLASS="l">1726</TD><TD>                        {</TD></TR><TR CLASS="z"><TD CLASS="l">1727</TD><TD>                            result = true;</TD></TR><TR><TD CLASS="l">1728</TD><TD>                        }</TD></TR><TR><TD CLASS="l">1729</TD><TD>                    }</TD></TR><TR><TD CLASS="l">1730</TD><TD>               }</TD></TR><TR><TD CLASS="l">1731</TD><TD>           }</TD></TR><TR><TD CLASS="l">1732</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1733</TD><TD>        if(result)</TD></TR><TR><TD CLASS="l">1734</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1735</TD><TD>            position.setParagraphStart();</TD></TR><TR><TD CLASS="l">1736</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1737</TD><TD>    }</TD></TR><TR><TD CLASS="l">1738</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="49">1739</A></TD><TD>    private float multiplyFloat(float value1, float value2)</TD></TR><TR><TD CLASS="l">1740</TD><TD>    {</TD></TR><TR><TD CLASS="l">1741</TD><TD>        // multiply 2 floats and truncate the resulting value to 3 decimal places</TD></TR><TR><TD CLASS="l">1742</TD><TD>        // to avoid wrong results when comparing with another float</TD></TR><TR CLASS="c"><TD CLASS="l">1743</TD><TD>        return Math.round(value1 * value2 * 1000) / 1000f;</TD></TR><TR><TD CLASS="l">1744</TD><TD>    }</TD></TR><TR><TD CLASS="l">1745</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1746</TD><TD>     * writes the paragraph separator string to the output.</TD></TR><TR><TD CLASS="l"><A NAME="5d">1747</A></TD><TD>     * @throws IOException if something went wrong</TD></TR><TR><TD CLASS="l">1748</TD><TD>     */</TD></TR><TR><TD CLASS="l">1749</TD><TD>    protected void writeParagraphSeparator()throws IOException</TD></TR><TR><TD CLASS="l">1750</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1751</TD><TD>        writeParagraphEnd();</TD></TR><TR CLASS="c"><TD CLASS="l">1752</TD><TD>        writeParagraphStart();</TD></TR><TR CLASS="c"><TD CLASS="l">1753</TD><TD>    }</TD></TR><TR><TD CLASS="l">1754</TD><TD> </TD></TR><TR><TD CLASS="l">1755</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1756</TD><TD>     * Write something (if defined) at the start of a paragraph.</TD></TR><TR><TD CLASS="l"><A NAME="2a">1757</A></TD><TD>     * @throws IOException if something went wrong</TD></TR><TR><TD CLASS="l">1758</TD><TD>     */</TD></TR><TR><TD CLASS="l">1759</TD><TD>    protected void writeParagraphStart() throws IOException</TD></TR><TR><TD CLASS="l">1760</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1761</TD><TD>        if (inParagraph) </TD></TR><TR><TD CLASS="l">1762</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1763</TD><TD>            writeParagraphEnd();</TD></TR><TR CLASS="z"><TD CLASS="l">1764</TD><TD>            inParagraph = false;</TD></TR><TR><TD CLASS="l">1765</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1766</TD><TD>        output.write(getParagraphStart());</TD></TR><TR CLASS="c"><TD CLASS="l">1767</TD><TD>        inParagraph = true;</TD></TR><TR CLASS="c"><TD CLASS="l">1768</TD><TD>    }</TD></TR><TR><TD CLASS="l">1769</TD><TD> </TD></TR><TR><TD CLASS="l">1770</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1771</TD><TD>     * Write something (if defined) at the end of a paragraph.</TD></TR><TR><TD CLASS="l"><A NAME="2f">1772</A></TD><TD>     * @throws IOException if something went wrong</TD></TR><TR><TD CLASS="l">1773</TD><TD>     */</TD></TR><TR><TD CLASS="l">1774</TD><TD>    protected void writeParagraphEnd() throws IOException</TD></TR><TR><TD CLASS="l">1775</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1776</TD><TD>        if (!inParagraph)</TD></TR><TR><TD CLASS="l">1777</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1778</TD><TD>            writeParagraphStart();</TD></TR><TR><TD CLASS="l">1779</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1780</TD><TD>        output.write(getParagraphEnd());</TD></TR><TR CLASS="c"><TD CLASS="l">1781</TD><TD>        inParagraph = false;</TD></TR><TR CLASS="c"><TD CLASS="l">1782</TD><TD>    }</TD></TR><TR><TD CLASS="l">1783</TD><TD> </TD></TR><TR><TD CLASS="l">1784</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1785</TD><TD>     * Write something (if defined) at the start of a page.</TD></TR><TR><TD CLASS="l"><A NAME="5c">1786</A></TD><TD>     * @throws IOException if something went wrong</TD></TR><TR><TD CLASS="l">1787</TD><TD>     */</TD></TR><TR><TD CLASS="l">1788</TD><TD>    protected void writePageStart()throws IOException</TD></TR><TR><TD CLASS="l">1789</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1790</TD><TD>        output.write(getPageStart());</TD></TR><TR CLASS="c"><TD CLASS="l">1791</TD><TD>    }</TD></TR><TR><TD CLASS="l">1792</TD><TD> </TD></TR><TR><TD CLASS="l">1793</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1794</TD><TD>     * Write something (if defined) at the end of a page.</TD></TR><TR><TD CLASS="l"><A NAME="5b">1795</A></TD><TD>     * @throws IOException if something went wrong</TD></TR><TR><TD CLASS="l">1796</TD><TD>     */</TD></TR><TR><TD CLASS="l">1797</TD><TD>    protected void writePageEnd()throws IOException</TD></TR><TR><TD CLASS="l">1798</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1799</TD><TD>        output.write(getPageEnd());</TD></TR><TR CLASS="c"><TD CLASS="l">1800</TD><TD>    }</TD></TR><TR><TD CLASS="l">1801</TD><TD> </TD></TR><TR><TD CLASS="l">1802</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1803</TD><TD>     * returns the list item Pattern object that matches</TD></TR><TR><TD CLASS="l">1804</TD><TD>     * the text at the specified PositionWrapper or null</TD></TR><TR><TD CLASS="l">1805</TD><TD>     * if the text does not match such a pattern.  The list</TD></TR><TR><TD CLASS="l">1806</TD><TD>     * of Patterns tested against is given by the</TD></TR><TR><TD CLASS="l">1807</TD><TD>     * {@link #getListItemPatterns()} method.  To add to</TD></TR><TR><TD CLASS="l">1808</TD><TD>     * the list, simply override that method (if sub-classing)</TD></TR><TR><TD CLASS="l">1809</TD><TD>     * or explicitly supply your own list using</TD></TR><TR><TD CLASS="l">1810</TD><TD>     * {@link #setListItemPatterns(List)}.</TD></TR><TR><TD CLASS="l">1811</TD><TD>     * @param pw position</TD></TR><TR><TD CLASS="l"><A NAME="48">1812</A></TD><TD>     * @return the matching pattern</TD></TR><TR><TD CLASS="l">1813</TD><TD>     */</TD></TR><TR><TD CLASS="l">1814</TD><TD>    protected Pattern matchListItemPattern(PositionWrapper pw) </TD></TR><TR><TD CLASS="l">1815</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1816</TD><TD>        TextPosition tp = pw.getTextPosition();</TD></TR><TR CLASS="c"><TD CLASS="l">1817</TD><TD>        String txt = tp.getCharacter();</TD></TR><TR CLASS="c"><TD CLASS="l">1818</TD><TD>        return matchPattern(txt,getListItemPatterns());</TD></TR><TR><TD CLASS="l">1819</TD><TD>    }</TD></TR><TR><TD CLASS="l">1820</TD><TD> </TD></TR><TR><TD CLASS="l">1821</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1822</TD><TD>     * a list of regular expressions that match commonly used</TD></TR><TR><TD CLASS="l">1823</TD><TD>     * list item formats, i.e. bullets, numbers, letters,</TD></TR><TR><TD CLASS="l">1824</TD><TD>     * Roman numerals, etc.  Not meant to be</TD></TR><TR><TD CLASS="l">1825</TD><TD>     * comprehensive.</TD></TR><TR><TD CLASS="l">1826</TD><TD>     */</TD></TR><TR CLASS="c"><TD CLASS="l">1827</TD><TD>    private static final String[] LIST_ITEM_EXPRESSIONS = {</TD></TR><TR><TD CLASS="l">1828</TD><TD>            &#34;\\.&#34;,</TD></TR><TR><TD CLASS="l">1829</TD><TD>            &#34;\\d+\\.&#34;,</TD></TR><TR><TD CLASS="l">1830</TD><TD>            &#34;\\[\\d+\\]&#34;,</TD></TR><TR><TD CLASS="l">1831</TD><TD>            &#34;\\d+\\)&#34;,</TD></TR><TR><TD CLASS="l">1832</TD><TD>            &#34;[A-Z]\\.&#34;,</TD></TR><TR><TD CLASS="l">1833</TD><TD>            &#34;[a-z]\\.&#34;,</TD></TR><TR><TD CLASS="l">1834</TD><TD>            &#34;[A-Z]\\)&#34;,</TD></TR><TR><TD CLASS="l">1835</TD><TD>            &#34;[a-z]\\)&#34;,</TD></TR><TR><TD CLASS="l">1836</TD><TD>            &#34;[IVXL]+\\.&#34;,</TD></TR><TR><TD CLASS="l">1837</TD><TD>            &#34;[ivxl]+\\.&#34;,</TD></TR><TR><TD CLASS="l">1838</TD><TD> </TD></TR><TR><TD CLASS="l">1839</TD><TD>    };</TD></TR><TR><TD CLASS="l">1840</TD><TD> </TD></TR><TR CLASS="p"><TD TITLE="34% line coverage (114 out of 340 instructions)" CLASS="l">1841</TD><TD TITLE="34% line coverage (114 out of 340 instructions)">    private List&lt;Pattern&gt; listOfPatterns = null;</TD></TR><TR><TD CLASS="l">1842</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1843</TD><TD>     * use to supply a different set of regular expression</TD></TR><TR><TD CLASS="l">1844</TD><TD>     * patterns for matching list item starts.</TD></TR><TR><TD CLASS="l">1845</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="1a">1846</A></TD><TD>     * @param patterns list of patterns</TD></TR><TR><TD CLASS="l">1847</TD><TD>     */</TD></TR><TR><TD CLASS="l">1848</TD><TD>    protected void setListItemPatterns(List&lt;Pattern&gt; patterns)</TD></TR><TR><TD CLASS="l">1849</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">1850</TD><TD>        listOfPatterns = patterns;</TD></TR><TR CLASS="z"><TD CLASS="l">1851</TD><TD>    }</TD></TR><TR><TD CLASS="l">1852</TD><TD> </TD></TR><TR><TD CLASS="l">1853</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1854</TD><TD>     * returns a list of regular expression Patterns representing</TD></TR><TR><TD CLASS="l">1855</TD><TD>     * different common list item formats.  For example</TD></TR><TR><TD CLASS="l">1856</TD><TD>     * numbered items of form:</TD></TR><TR><TD CLASS="l">1857</TD><TD>     * &lt;ol&gt;</TD></TR><TR><TD CLASS="l">1858</TD><TD>     * &lt;li&gt;some text&lt;/li&gt;</TD></TR><TR><TD CLASS="l">1859</TD><TD>     * &lt;li&gt;more text&lt;/li&gt;</TD></TR><TR><TD CLASS="l">1860</TD><TD>     * &lt;/ol&gt;</TD></TR><TR><TD CLASS="l">1861</TD><TD>     * or</TD></TR><TR><TD CLASS="l">1862</TD><TD>     * &lt;ul&gt;</TD></TR><TR><TD CLASS="l">1863</TD><TD>     * &lt;li&gt;some text&lt;/li&gt;</TD></TR><TR><TD CLASS="l">1864</TD><TD>     * &lt;li&gt;more text&lt;/li&gt;</TD></TR><TR><TD CLASS="l">1865</TD><TD>     * &lt;/ul&gt;</TD></TR><TR><TD CLASS="l">1866</TD><TD>     * etc., all begin with some character pattern. The pattern &#34;\\d+\.&#34; (matches &#34;1.&#34;, &#34;2.&#34;, ...)</TD></TR><TR><TD CLASS="l">1867</TD><TD>     * or &#34;\[\\d+\]&#34; (matches &#34;[1]&#34;, &#34;[2]&#34;, ...).</TD></TR><TR><TD CLASS="l">1868</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1869</TD><TD>     * This method returns a list of such regular expression Patterns.</TD></TR><TR><TD CLASS="l"><A NAME="40">1870</A></TD><TD>     * @return a list of Pattern objects.</TD></TR><TR><TD CLASS="l">1871</TD><TD>     */</TD></TR><TR><TD CLASS="l">1872</TD><TD>    protected List&lt;Pattern&gt; getListItemPatterns()</TD></TR><TR><TD CLASS="l">1873</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1874</TD><TD>        if(listOfPatterns == null)</TD></TR><TR><TD CLASS="l">1875</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1876</TD><TD>            listOfPatterns = new ArrayList&lt;Pattern&gt;();</TD></TR><TR CLASS="c"><TD CLASS="l">1877</TD><TD>            for(String expression : LIST_ITEM_EXPRESSIONS)</TD></TR><TR><TD CLASS="l">1878</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">1879</TD><TD>                Pattern p = Pattern.compile(expression);</TD></TR><TR CLASS="c"><TD CLASS="l">1880</TD><TD>                listOfPatterns.add(p);</TD></TR><TR><TD CLASS="l">1881</TD><TD>            }</TD></TR><TR><TD CLASS="l">1882</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1883</TD><TD>        return listOfPatterns;</TD></TR><TR><TD CLASS="l">1884</TD><TD>    }</TD></TR><TR><TD CLASS="l">1885</TD><TD> </TD></TR><TR><TD CLASS="l">1886</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1887</TD><TD>     * iterates over the specified list of Patterns until</TD></TR><TR><TD CLASS="l">1888</TD><TD>     * it finds one that matches the specified string.  Then</TD></TR><TR><TD CLASS="l">1889</TD><TD>     * returns the Pattern.</TD></TR><TR><TD CLASS="l">1890</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">1891</TD><TD>     * Order of the supplied list of patterns is important as</TD></TR><TR><TD CLASS="l">1892</TD><TD>     * most common patterns should come first.  Patterns</TD></TR><TR><TD CLASS="l">1893</TD><TD>     * should be strict in general, and all will be</TD></TR><TR><TD CLASS="l">1894</TD><TD>     * used with case sensitivity on.</TD></TR><TR><TD CLASS="l">1895</TD><TD>     * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">1896</TD><TD>     * @param string the string to be searched </TD></TR><TR><TD CLASS="l">1897</TD><TD>     * @param patterns list of patterns</TD></TR><TR><TD CLASS="l"><A NAME="32">1898</A></TD><TD>     * @return matching pattern</TD></TR><TR><TD CLASS="l">1899</TD><TD>     */</TD></TR><TR><TD CLASS="l">1900</TD><TD>    protected static final Pattern matchPattern(String string, List&lt;Pattern&gt; patterns)</TD></TR><TR><TD CLASS="l">1901</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1902</TD><TD>        Pattern matchedPattern = null;</TD></TR><TR CLASS="c"><TD CLASS="l">1903</TD><TD>        for(Pattern p : patterns)</TD></TR><TR><TD CLASS="l">1904</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1905</TD><TD>            if(p.matcher(string).matches())</TD></TR><TR><TD CLASS="l">1906</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1907</TD><TD>                return p;</TD></TR><TR><TD CLASS="l">1908</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">1909</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1910</TD><TD>        return matchedPattern;</TD></TR><TR><TD CLASS="l">1911</TD><TD>    }</TD></TR><TR><TD CLASS="l">1912</TD><TD> </TD></TR><TR><TD CLASS="l">1913</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1914</TD><TD>     * Write a list of string containing a whole line of a document.</TD></TR><TR><TD CLASS="l">1915</TD><TD>     * @param line a list with the words of the given line</TD></TR><TR><TD CLASS="l">1916</TD><TD>     * @param isRtlDominant determines if rtl or ltl is dominant</TD></TR><TR><TD CLASS="l"><A NAME="33">1917</A></TD><TD>     * @throws IOException if something went wrong</TD></TR><TR><TD CLASS="l">1918</TD><TD>     */</TD></TR><TR><TD CLASS="l">1919</TD><TD>    private void writeLine(List&lt;WordWithTextPositions&gt; line, boolean isRtlDominant) throws IOException</TD></TR><TR><TD CLASS="l">1920</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1921</TD><TD>        int numberOfStrings = line.size();</TD></TR><TR CLASS="c"><TD CLASS="l">1922</TD><TD>        for(int i=0; i&lt;numberOfStrings; i++)</TD></TR><TR><TD CLASS="l">1923</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1924</TD><TD>            WordWithTextPositions word = line.get(i);</TD></TR><TR CLASS="c"><TD CLASS="l">1925</TD><TD>            writeString(word.getText(), word.getTextPositions());</TD></TR><TR CLASS="c"><TD CLASS="l">1926</TD><TD>            if (i &lt; numberOfStrings-1)</TD></TR><TR><TD CLASS="l">1927</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1928</TD><TD>                writeWordSeparator();</TD></TR><TR><TD CLASS="l">1929</TD><TD>            }</TD></TR><TR><TD CLASS="l">1930</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1931</TD><TD>    }</TD></TR><TR><TD CLASS="l">1932</TD><TD> </TD></TR><TR><TD CLASS="l">1933</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1934</TD><TD>     * Normalize the given list of TextPositions.</TD></TR><TR><TD CLASS="l">1935</TD><TD>     * @param line list of TextPositions</TD></TR><TR><TD CLASS="l">1936</TD><TD>     * @param isRtlDominant determines if rtl or ltl is dominant </TD></TR><TR><TD CLASS="l">1937</TD><TD>     * @param hasRtl determines if lines contains rtl formatted text(parts)</TD></TR><TR><TD CLASS="l"><A NAME="29">1938</A></TD><TD>     * @return a list of strings, one string for every word</TD></TR><TR><TD CLASS="l">1939</TD><TD>     */</TD></TR><TR><TD CLASS="l">1940</TD><TD>    private List&lt;WordWithTextPositions&gt; normalize(List&lt;TextPosition&gt; line, boolean isRtlDominant, boolean hasRtl)</TD></TR><TR><TD CLASS="l">1941</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1942</TD><TD>        LinkedList&lt;WordWithTextPositions&gt; normalized = new LinkedList&lt;WordWithTextPositions&gt;();</TD></TR><TR CLASS="c"><TD CLASS="l">1943</TD><TD>        StringBuilder lineBuilder = new StringBuilder();</TD></TR><TR CLASS="c"><TD CLASS="l">1944</TD><TD>        List&lt;TextPosition&gt; wordPositions = new ArrayList&lt;TextPosition&gt;();</TD></TR><TR><TD CLASS="l">1945</TD><TD>        // concatenate the pieces of text in opposite order if RTL is dominant</TD></TR><TR CLASS="c"><TD CLASS="l">1946</TD><TD>        if (isRtlDominant)</TD></TR><TR><TD CLASS="l">1947</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1948</TD><TD>            int numberOfPositions = line.size();</TD></TR><TR CLASS="z"><TD CLASS="l">1949</TD><TD>            for(int i = numberOfPositions-1;i&gt;=0;i--)</TD></TR><TR><TD CLASS="l">1950</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">1951</TD><TD>                lineBuilder = normalizeAdd(normalized, lineBuilder, wordPositions, line.get(i));</TD></TR><TR><TD CLASS="l">1952</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">1953</TD><TD>        }</TD></TR><TR><TD CLASS="l">1954</TD><TD>        else</TD></TR><TR><TD CLASS="l">1955</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1956</TD><TD>            for(TextPosition text : line)</TD></TR><TR><TD CLASS="l">1957</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">1958</TD><TD>                lineBuilder = normalizeAdd(normalized, lineBuilder, wordPositions, text);</TD></TR><TR CLASS="c"><TD CLASS="l">1959</TD><TD>            }</TD></TR><TR><TD CLASS="l">1960</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1961</TD><TD>        if (lineBuilder.length() &gt; 0) </TD></TR><TR><TD CLASS="l">1962</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1963</TD><TD>            normalized.add(createWord(lineBuilder.toString(), wordPositions));</TD></TR><TR><TD CLASS="l">1964</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1965</TD><TD>        return normalized;</TD></TR><TR><TD CLASS="l">1966</TD><TD>    }</TD></TR><TR><TD CLASS="l">1967</TD><TD> </TD></TR><TR><TD CLASS="l">1968</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1969</TD><TD>     * Used within {@link #normalize(List, boolean, boolean)} to create a single {@link WordWithTextPositions}</TD></TR><TR><TD CLASS="l"><A NAME="35">1970</A></TD><TD>     * entry.</TD></TR><TR><TD CLASS="l">1971</TD><TD>     */</TD></TR><TR><TD CLASS="l">1972</TD><TD>    private WordWithTextPositions createWord(String word, List&lt;TextPosition&gt; wordPositions)</TD></TR><TR><TD CLASS="l">1973</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1974</TD><TD>        return new WordWithTextPositions(normalize.normalizePres(word), wordPositions);</TD></TR><TR><TD CLASS="l">1975</TD><TD>    }</TD></TR><TR><TD CLASS="l">1976</TD><TD> </TD></TR><TR><TD CLASS="l">1977</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1978</TD><TD>     * Used within {@link #normalize(List, boolean, boolean)} to handle a {@link TextPosition}.</TD></TR><TR><TD CLASS="l">1979</TD><TD>     * @return The StringBuilder that must be used when calling this method.</TD></TR><TR><TD CLASS="l"><A NAME="25">1980</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">1981</TD><TD>    private StringBuilder normalizeAdd(LinkedList&lt;WordWithTextPositions&gt; normalized,</TD></TR><TR><TD CLASS="l">1982</TD><TD>            StringBuilder lineBuilder, List&lt;TextPosition&gt; wordPositions, TextPosition text)</TD></TR><TR><TD CLASS="l">1983</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">1984</TD><TD>        if (text instanceof WordSeparator) </TD></TR><TR><TD CLASS="l">1985</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">1986</TD><TD>            normalized.add(createWord(lineBuilder.toString(), new ArrayList&lt;TextPosition&gt;(wordPositions)));</TD></TR><TR CLASS="z"><TD CLASS="l">1987</TD><TD>            lineBuilder = new StringBuilder();</TD></TR><TR CLASS="z"><TD CLASS="l">1988</TD><TD>            wordPositions.clear();</TD></TR><TR><TD CLASS="l">1989</TD><TD>        }</TD></TR><TR><TD CLASS="l">1990</TD><TD>        else </TD></TR><TR><TD CLASS="l">1991</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">1992</TD><TD>            lineBuilder.append(text.getCharacter());</TD></TR><TR CLASS="c"><TD CLASS="l">1993</TD><TD>            wordPositions.add(text);</TD></TR><TR><TD CLASS="l">1994</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">1995</TD><TD>        return lineBuilder;</TD></TR><TR><TD CLASS="l">1996</TD><TD>    }</TD></TR><TR><TD CLASS="l">1997</TD><TD> </TD></TR><TR><TD CLASS="l">1998</TD><TD>    /**</TD></TR><TR><TD CLASS="l">1999</TD><TD>     * internal marker class.  Used as a place holder in</TD></TR><TR><TD CLASS="l">2000</TD><TD>     * a line of TextPositions.</TD></TR><TR><TD CLASS="l">2001</TD><TD>     * @author ME21969</TD></TR><TR><TD CLASS="l"><A NAME="0">2002</A></TD><TD>     *</TD></TR><TR><TD CLASS="l">2003</TD><TD>     */</TD></TR><TR><TD CLASS="l">2004</TD><TD>    private static final class WordSeparator extends TextPosition</TD></TR><TR><TD CLASS="l"><A NAME="2">2005</A></TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">2006</TD><TD>        private static final WordSeparator separator = new WordSeparator();</TD></TR><TR><TD CLASS="l">2007</TD><TD>        </TD></TR><TR><TD CLASS="l">2008</TD><TD>        private WordSeparator()</TD></TR><TR CLASS="z"><TD CLASS="l">2009</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="3">2010</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">2011</TD><TD> </TD></TR><TR><TD CLASS="l">2012</TD><TD>        public static final WordSeparator getSeparator()</TD></TR><TR><TD CLASS="l">2013</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">2014</TD><TD>            return separator;</TD></TR><TR><TD CLASS="l">2015</TD><TD>        }</TD></TR><TR><TD CLASS="l">2016</TD><TD>    }</TD></TR><TR><TD CLASS="l">2017</TD><TD> </TD></TR><TR><TD CLASS="l">2018</TD><TD>    /**</TD></TR><TR><TD CLASS="l">2019</TD><TD>     * Internal class that maps strings to lists of {@link TextPosition} arrays.</TD></TR><TR><TD CLASS="l">2020</TD><TD>     * Note that the number of entries in that list may differ from the number of characters in the</TD></TR><TR><TD CLASS="l">2021</TD><TD>     * string due to normalization.</TD></TR><TR><TD CLASS="l">2022</TD><TD>     *</TD></TR><TR><TD CLASS="l">2023</TD><TD>     * @author Axel D�rfler</TD></TR><TR><TD CLASS="l">2024</TD><TD>     */</TD></TR><TR><TD CLASS="l">2025</TD><TD>    private static final class WordWithTextPositions</TD></TR><TR><TD CLASS="l">2026</TD><TD>    {</TD></TR><TR><TD CLASS="l"><A NAME="60">2027</A></TD><TD>        protected String text;</TD></TR><TR><TD CLASS="l">2028</TD><TD>        protected List&lt;TextPosition&gt; textPositions;</TD></TR><TR><TD CLASS="l">2029</TD><TD>        </TD></TR><TR><TD CLASS="l">2030</TD><TD>        public WordWithTextPositions(String word, List&lt;TextPosition&gt; positions)</TD></TR><TR CLASS="c"><TD CLASS="l">2031</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">2032</TD><TD>            text = word;</TD></TR><TR CLASS="c"><TD CLASS="l">2033</TD><TD>            textPositions = positions;</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="62">2034</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">2035</TD><TD>        </TD></TR><TR><TD CLASS="l">2036</TD><TD>        public String getText()</TD></TR><TR><TD CLASS="l">2037</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">2038</TD><TD>            return text;</TD></TR><TR><TD CLASS="l"><A NAME="63">2039</A></TD><TD>        }</TD></TR><TR><TD CLASS="l">2040</TD><TD> </TD></TR><TR><TD CLASS="l">2041</TD><TD>        public List&lt;TextPosition&gt; getTextPositions()</TD></TR><TR><TD CLASS="l">2042</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">2043</TD><TD>            return textPositions;</TD></TR><TR><TD CLASS="l">2044</TD><TD>        }</TD></TR><TR><TD CLASS="l">2045</TD><TD>    }</TD></TR><TR><TD CLASS="l">2046</TD><TD>}</TD></TR></TABLE><P></P><TABLE WIDTH="100%" CLASS="hdft" CELLSPACING="0"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="24.html">org.apache.pdfbox.util</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.1.5320 (stable)</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>