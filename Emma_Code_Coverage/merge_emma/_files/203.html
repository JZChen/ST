<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE WIDTH="100%" CLASS="hdft" CELLSPACING="0"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Fri Jun 05 14:13:45 PDT 2015)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="26.html">org.apache.pdfbox.util</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">DateConverter.java</SPAN>]</H2><TABLE WIDTH="100%" CELLSPACING="0"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>DateConverter.java</TD><TD>100% (1/1)</TD><TD>89%  (17/19)</TD><TD>91%  (782/863)</TD><TD>88%  (155/176)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE WIDTH="100%" CLASS="cn" CELLSPACING="0"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">DateConverter</A></TD><TD>100% (1/1)</TD><TD>89%  (17/19)</TD><TD>91%  (782/863)</TD><TD>88%  (155/176)</TD></TR><TR><TD CLASS="f"><A HREF="#1">DateConverter (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">getFormats (): String []</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#3">parseDate (String, String [], ParsePosition): Calendar</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">70%  (102/146)</TD><TD CLASS="h">72%  (31/43)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">toString (Calendar): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>93%  (26/28)</TD><TD>80%  (4/5)</TD></TR><TR><TD CLASS="f"><A HREF="#5">parseBigEndianDate (String, ParsePosition): GregorianCalendar</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>95%  (114/120)</TD><TD>96%  (25/26)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">parseTimeField (String, ParsePosition, int, int): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>96%  (50/52)</TD><TD>93%  (13/14)</TD></TR><TR><TD CLASS="f"><A HREF="#0">&lt;static initializer&gt;</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (67/67)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">adjustTimeZoneNicely (GregorianCalendar, TimeZone): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (19/19)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#9">formatTZoffset (long, String): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (35/35)</TD><TD>100% (4/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">newGreg (): GregorianCalendar</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (21/21)</TD><TD>100% (5/5)</TD></TR><TR><TD CLASS="f"><A HREF="#b">parseSimpleDate (String, String [], ParsePosition): GregorianCalendar</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (51/51)</TD><TD>100% (10/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">parseTZoffset (String, GregorianCalendar, ParsePosition): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (123/123)</TD><TD>100% (24/24)</TD></TR><TR><TD CLASS="f"><A HREF="#d">restrainTZoffset (long): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (19/19)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">skipOptionals (String, ParsePosition, String): char</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (34/34)</TD><TD>100% (7/7)</TD></TR><TR><TD CLASS="f"><A HREF="#f">skipString (String, String, ParsePosition): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (17/17)</TD><TD>100% (4/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">toCalendar (COSString): Calendar</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (3/3)</TD></TR><TR><TD CLASS="f"><A HREF="#11">toCalendar (String): Calendar</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (33/33)</TD><TD>100% (6/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">toCalendar (String, String []): Calendar</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (39/39)</TD><TD>100% (8/8)</TD></TR><TR><TD CLASS="f"><A HREF="#13">toISO8601 (Calendar): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (24/24)</TD><TD>100% (3/3)</TD></TR></TABLE><P></P><TABLE WIDTH="100%" CLASS="s" CELLSPACING="0"><TR><TD CLASS="l">1</TD><TD>/*</TD></TR><TR><TD CLASS="l">2</TD><TD> * Licensed to the Apache Software Foundation (ASF) under one or more</TD></TR><TR><TD CLASS="l">3</TD><TD> * contributor license agreements.  See the NOTICE file distributed with</TD></TR><TR><TD CLASS="l">4</TD><TD> * this work for additional information regarding copyright ownership.</TD></TR><TR><TD CLASS="l">5</TD><TD> * The ASF licenses this file to You under the Apache License, Version 2.0</TD></TR><TR><TD CLASS="l">6</TD><TD> * (the &#34;License&#34;); you may not use this file except in compliance with</TD></TR><TR><TD CLASS="l">7</TD><TD> * the License.  You may obtain a copy of the License at</TD></TR><TR><TD CLASS="l">8</TD><TD> *</TD></TR><TR><TD CLASS="l">9</TD><TD> *      http://www.apache.org/licenses/LICENSE-2.0</TD></TR><TR><TD CLASS="l">10</TD><TD> *</TD></TR><TR><TD CLASS="l">11</TD><TD> * Unless required by applicable law or agreed to in writing, software</TD></TR><TR><TD CLASS="l">12</TD><TD> * distributed under the License is distributed on an &#34;AS IS&#34; BASIS,</TD></TR><TR><TD CLASS="l">13</TD><TD> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</TD></TR><TR><TD CLASS="l">14</TD><TD> * See the License for the specific language governing permissions and</TD></TR><TR><TD CLASS="l">15</TD><TD> * limitations under the License.</TD></TR><TR><TD CLASS="l">16</TD><TD> */</TD></TR><TR><TD CLASS="l">17</TD><TD>package org.apache.pdfbox.util;</TD></TR><TR><TD CLASS="l">18</TD><TD> </TD></TR><TR><TD CLASS="l">19</TD><TD>import java.io.IOException;</TD></TR><TR><TD CLASS="l">20</TD><TD>import java.text.ParsePosition;</TD></TR><TR><TD CLASS="l">21</TD><TD>import java.text.SimpleDateFormat;</TD></TR><TR><TD CLASS="l">22</TD><TD>import java.util.Calendar;</TD></TR><TR><TD CLASS="l">23</TD><TD>import java.util.Date;</TD></TR><TR><TD CLASS="l">24</TD><TD>import java.util.GregorianCalendar;</TD></TR><TR><TD CLASS="l">25</TD><TD>import java.util.Locale;</TD></TR><TR><TD CLASS="l">26</TD><TD>import java.util.SimpleTimeZone;</TD></TR><TR><TD CLASS="l">27</TD><TD>import java.util.TimeZone;</TD></TR><TR><TD CLASS="l">28</TD><TD> </TD></TR><TR><TD CLASS="l">29</TD><TD>import org.apache.pdfbox.cos.COSString;</TD></TR><TR><TD CLASS="l">30</TD><TD> </TD></TR><TR><TD CLASS="l">31</TD><TD>/**</TD></TR><TR><TD CLASS="l">32</TD><TD> * Date format is described in PDF Reference 1.7 section 3.8.2</TD></TR><TR><TD CLASS="l">33</TD><TD> * (www.adobe.com/devnet/acrobat/pdfs/pdf_reference_1-7.pdf)</TD></TR><TR><TD CLASS="l">34</TD><TD> * and also in PDF 32000-1:2008 </TD></TR><TR><TD CLASS="l">35</TD><TD> * (http://www.adobe.com/devnet/acrobat/pdfs/PDF32000_2008.pdf))</TD></TR><TR><TD CLASS="l">36</TD><TD> * although the latter inexplicably omits the trailing apostrophe.</TD></TR><TR><TD CLASS="l">37</TD><TD> * </TD></TR><TR><TD CLASS="l">38</TD><TD> * The interpretation of dates without timezones is unclear. </TD></TR><TR><TD CLASS="l">39</TD><TD> * The code below assumes that such dates are in UTC+00 (aka GMT).</TD></TR><TR><TD CLASS="l">40</TD><TD> * This is in keeping with the PDF Reference's assertion that:</TD></TR><TR><TD CLASS="l">41</TD><TD> *      numerical fields default to zero values. </TD></TR><TR><TD CLASS="l">42</TD><TD> * However, the Reference does go on to make the cryptic remark:</TD></TR><TR><TD CLASS="l">43</TD><TD> *      If no UT information is specified, the relationship of the specified  </TD></TR><TR><TD CLASS="l">44</TD><TD> *      time to UT is considered to be unknown. Whether or not the time </TD></TR><TR><TD CLASS="l">45</TD><TD> *      zone is known, the rest of the date should be specified in local time.</TD></TR><TR><TD CLASS="l">46</TD><TD> * I understand this to refer to _creating_ a pdf date value. That is, </TD></TR><TR><TD CLASS="l">47</TD><TD> * code that can get the wall clock time and cannot get the timezone </TD></TR><TR><TD CLASS="l">48</TD><TD> * should write the wall clock time with a time zone of zero.</TD></TR><TR><TD CLASS="l">49</TD><TD> * When _parsing_ a PDF date, the statement talks about &#34;the rest of the date&#34;</TD></TR><TR><TD CLASS="l">50</TD><TD> * being local time, thus explicitly excluding the use of the local time</TD></TR><TR><TD CLASS="l">51</TD><TD> * for the time zone.</TD></TR><TR><TD CLASS="l">52</TD><TD>*/ </TD></TR><TR><TD CLASS="l">53</TD><TD> </TD></TR><TR><TD CLASS="l">54</TD><TD>/**</TD></TR><TR><TD CLASS="l">55</TD><TD> * This class is used to convert dates to strings and back using the PDF</TD></TR><TR><TD CLASS="l">56</TD><TD> * date standard in section 3.8.2 of PDF Reference 1.7.  </TD></TR><TR><TD CLASS="l">57</TD><TD> *</TD></TR><TR><TD CLASS="l">58</TD><TD> * @author &lt;a href=&#34;mailto:ben@benlitchfield.com&#34;&gt;Ben Litchfield&lt;/a&gt;</TD></TR><TR><TD CLASS="l">59</TD><TD> * @author &lt;a href=&#34;mailto:zweibieren@ahoo.com&#34;&gt;Fred Hansen&lt;/a&gt;</TD></TR><TR><TD CLASS="l">60</TD><TD> * </TD></TR><TR><TD CLASS="l">61</TD><TD> * TODO Move members of this class elsewhere for shared use in pdfbox, xmpbox, and jempbox.</TD></TR><TR><TD CLASS="l">62</TD><TD> */</TD></TR><TR><TD CLASS="l">63</TD><TD>public class DateConverter</TD></TR><TR><TD CLASS="l">64</TD><TD>{</TD></TR><TR><TD CLASS="l">65</TD><TD>    // milliseconds/1000 = seconds; seconds / 60 = minutes; minutes/60 = hours</TD></TR><TR><TD CLASS="l">66</TD><TD>    private static final int MINUTES_PER_HOUR = 60;</TD></TR><TR><TD CLASS="l">67</TD><TD>    private static final int SECONDS_PER_MINUTE = 60;</TD></TR><TR><TD CLASS="l">68</TD><TD>    private static final int MILLIS_PER_MINUTE = SECONDS_PER_MINUTE*1000;</TD></TR><TR><TD CLASS="l">69</TD><TD>    private static final int MILLIS_PER_HOUR = MINUTES_PER_HOUR * MILLIS_PER_MINUTE;</TD></TR><TR><TD CLASS="l">70</TD><TD>    private static final int </TD></TR><TR><TD CLASS="l">71</TD><TD>            HALF_DAY = 12 * MINUTES_PER_HOUR * MILLIS_PER_MINUTE, </TD></TR><TR><TD CLASS="l">72</TD><TD>            DAY = 2*HALF_DAY;</TD></TR><TR><TD CLASS="l">73</TD><TD>    </TD></TR><TR><TD CLASS="l">74</TD><TD>    /**</TD></TR><TR><TD CLASS="l">75</TD><TD>     * Error value if date is invalid. Parsing is done with </TD></TR><TR><TD CLASS="l">76</TD><TD>     * GregorianCalendar.setLenient(false), so every date field value</TD></TR><TR><TD CLASS="l">77</TD><TD>     * must be within bounds. If an attempt is made to parse an invalid date </TD></TR><TR><TD CLASS="l">78</TD><TD>     * field, toCalendar(String, String[]) returns Jan 1 in year INVALID_YEAR.</TD></TR><TR><TD CLASS="l">79</TD><TD>     */</TD></TR><TR><TD CLASS="l">80</TD><TD>    public static final int INVALID_YEAR = 999;</TD></TR><TR><TD CLASS="l">81</TD><TD>    </TD></TR><TR><TD CLASS="l">82</TD><TD>    </TD></TR><TR><TD CLASS="l">83</TD><TD>    /**</TD></TR><TR><TD CLASS="l">84</TD><TD>     * The Date format is supposed to be the PDF_DATE_FORMAT, but other</TD></TR><TR><TD CLASS="l">85</TD><TD>     * forms appear. These lists offer alternatives to be tried </TD></TR><TR><TD CLASS="l">86</TD><TD>     * if parseBigEndianDate fails.  </TD></TR><TR><TD CLASS="l">87</TD><TD>     * </TD></TR><TR><TD CLASS="l">88</TD><TD>     * The time zone offset generally trails the date string, so it is processed</TD></TR><TR><TD CLASS="l">89</TD><TD>     * separately with parseTZoffset. (This does not preclude having time</TD></TR><TR><TD CLASS="l">90</TD><TD>     * zones in the elements below; one does.)</TD></TR><TR><TD CLASS="l">91</TD><TD>     * </TD></TR><TR><TD CLASS="l">92</TD><TD>     * Alas, SimpleDateFormat is badly non-reentrant -- it modifies its </TD></TR><TR><TD CLASS="l">93</TD><TD>     * calendar field (PDFBox-402), so these lists are strings to create</TD></TR><TR><TD CLASS="l">94</TD><TD>     * SimpleDate format as needed.</TD></TR><TR><TD CLASS="l">95</TD><TD>     * </TD></TR><TR><TD CLASS="l">96</TD><TD>     * Some past entries have been elided because they duplicate existing </TD></TR><TR><TD CLASS="l">97</TD><TD>     * entries. See the API for SimpleDateFormat, which says </TD></TR><TR><TD CLASS="l">98</TD><TD>     *      &#34;For parsing, the number of pattern letters is ignored </TD></TR><TR><TD CLASS="l">99</TD><TD>     *      unless it's needed to separate two adjacent fields.&#34;</TD></TR><TR><TD CLASS="l">100</TD><TD>     * </TD></TR><TR><TD CLASS="l">101</TD><TD>     * toCalendar(String, String[]) tests to see that the entire input text</TD></TR><TR><TD CLASS="l">102</TD><TD>     * has been consumed. Therefore the ordering of formats is important. </TD></TR><TR><TD CLASS="l">103</TD><TD>     * If one format begins with the entirety of another, the longer</TD></TR><TR><TD CLASS="l">104</TD><TD>     * must precede the other in the list.</TD></TR><TR><TD CLASS="l">105</TD><TD>     * </TD></TR><TR><TD CLASS="l">106</TD><TD>     * HH is for 0-23 hours and hh for 1-12 hours; an &#34;a&#34; field must follow &#34;hh&#34;</TD></TR><TR><TD CLASS="l"><A NAME="0">107</A></TD><TD>     * Where year is yy, four digit years are accepted </TD></TR><TR><TD CLASS="l">108</TD><TD>     * and two digit years are converted to four digits in the range</TD></TR><TR><TD CLASS="l">109</TD><TD>     *      [thisyear-79...thisyear+20]</TD></TR><TR><TD CLASS="l">110</TD><TD>     */</TD></TR><TR CLASS="c"><TD CLASS="l">111</TD><TD>    private static final String[] ALPHA_START_FORMATS = </TD></TR><TR><TD CLASS="l">112</TD><TD>    {</TD></TR><TR><TD CLASS="l">113</TD><TD>            &#34;EEEE, dd MMM yy hh:mm:ss a&#34;,</TD></TR><TR><TD CLASS="l">114</TD><TD>            &#34;EEEE, MMM dd, yy hh:mm:ss a&#34;,</TD></TR><TR><TD CLASS="l">115</TD><TD>            &#34;EEEE, MMM dd, yy 'at' hh:mma&#34;, // Acrobat Net Distiller 1.0 for Windows</TD></TR><TR><TD CLASS="l">116</TD><TD>            &#34;EEEE, MMM dd, yy&#34;, // Acrobat Distiller 1.0.2 for Macintosh  &amp;&amp; PDFBOX-465</TD></TR><TR><TD CLASS="l">117</TD><TD>            &#34;EEEE MMM dd, yy HH:mm:ss&#34;, // ECMP5</TD></TR><TR><TD CLASS="l">118</TD><TD>            &#34;EEEE MMM dd HH:mm:ss z yy&#34;, // GNU Ghostscript 7.0.7</TD></TR><TR><TD CLASS="l">119</TD><TD>            &#34;EEEE MMM dd HH:mm:ss yy&#34;, // GNU Ghostscript 7.0.7 variant</TD></TR><TR><TD CLASS="l">120</TD><TD>    };</TD></TR><TR><TD CLASS="l">121</TD><TD>    </TD></TR><TR CLASS="c"><TD CLASS="l">122</TD><TD>    private static final String[] DIGIT_START_FORMATS = </TD></TR><TR><TD CLASS="l">123</TD><TD>    {</TD></TR><TR><TD CLASS="l">124</TD><TD>        &#34;dd MMM yy HH:mm:ss&#34;,  // for 26 May 2000 11:25:00</TD></TR><TR><TD CLASS="l">125</TD><TD>        &#34;dd MMM yy HH:mm&#34;,  // for 26 May 2000 11:25</TD></TR><TR><TD CLASS="l">126</TD><TD>        &#34;yyyy MMM d&#34;,   // ambiguity resolved only by omitting time</TD></TR><TR><TD CLASS="l">127</TD><TD>        &#34;yyyymmddhh:mm:ss&#34;, // test case &#34;200712172:2:3&#34;</TD></TR><TR><TD CLASS="l">128</TD><TD>        &#34;H:m M/d/yy&#34;, // test case &#34;9:47 5/12/2008&#34;</TD></TR><TR><TD CLASS="l">129</TD><TD>        &#34;M/d/yy HH:mm:ss&#34;,</TD></TR><TR><TD CLASS="l">130</TD><TD>        &#34;M/d/yy HH:mm&#34;,</TD></TR><TR><TD CLASS="l">131</TD><TD>        &#34;M/d/yy&#34;,</TD></TR><TR><TD CLASS="l">132</TD><TD> </TD></TR><TR><TD CLASS="l">133</TD><TD>        // proposed rule that is unreachable due to &#34;dd MMM yy HH:mm:ss&#34; </TD></TR><TR><TD CLASS="l">134</TD><TD>        //     &#34;yyyy MMM d HH:mm:ss&#34;, </TD></TR><TR><TD CLASS="l">135</TD><TD> </TD></TR><TR><TD CLASS="l">136</TD><TD>        // rules made unreachable by &#34;M/d/yy HH:mm:ss&#34; &#34;M/d/yy HH:mm&#34;  &#34;M/d/yy&#34;,</TD></TR><TR><TD CLASS="l">137</TD><TD>        // (incoming digit strings do not mark themselves as y, m, or d!)</TD></TR><TR><TD CLASS="l">138</TD><TD>            // &#34;d/MM/yyyy HH:mm:ss&#34;, // PDFBOX-164 and PDFBOX-170 </TD></TR><TR><TD CLASS="l">139</TD><TD>            // &#34;M/dd/yyyy hh:mm:ss&#34;,</TD></TR><TR><TD CLASS="l">140</TD><TD>            // &#34;MM/d/yyyy hh:mm:ss&#34;,</TD></TR><TR><TD CLASS="l">141</TD><TD>            // &#34;M/d/yyyy HH:mm:ss&#34;,</TD></TR><TR><TD CLASS="l">142</TD><TD>            // &#34;M/dd/yyyy&#34;,</TD></TR><TR><TD CLASS="l">143</TD><TD>            // &#34;MM/d/yyyy&#34;,</TD></TR><TR><TD CLASS="l">144</TD><TD>            // &#34;M/d/yyyy&#34;,</TD></TR><TR><TD CLASS="l">145</TD><TD>            // &#34;M/d/yyyy HH:mm:ss&#34;,</TD></TR><TR><TD CLASS="l">146</TD><TD>            // &#34;M/d/yy HH:mm:ss&#34;,</TD></TR><TR><TD CLASS="l">147</TD><TD>        // subsumed by big-endian parse</TD></TR><TR><TD CLASS="l">148</TD><TD>            // &#34;yyyy-MM-dd'T'HH:mm:ss&#34;,</TD></TR><TR><TD CLASS="l">149</TD><TD>            // &#34;yyyy-MM-dd'T'HH:mm:ss&#34;,</TD></TR><TR><TD CLASS="l">150</TD><TD>            // &#34;yyyymmdd hh:mm:ss&#34;, </TD></TR><TR><TD CLASS="l">151</TD><TD>            // &#34;yyyymmdd&#34;, </TD></TR><TR><TD CLASS="l">152</TD><TD>            // &#34;yyyymmddX''00''&#34;,  // covers 24 cases </TD></TR><TR><TD CLASS="l">153</TD><TD>            //    (orignally the above ended with '+00''00'''; </TD></TR><TR><TD CLASS="l">154</TD><TD>            //      the first apostrophe quoted the plus, </TD></TR><TR><TD CLASS="l">155</TD><TD>            //      '' mapped to a single ', and the ''' was invalid)</TD></TR><TR><TD CLASS="l"><A NAME="1">156</A></TD><TD>    };</TD></TR><TR><TD CLASS="l">157</TD><TD> </TD></TR><TR><TD CLASS="l">158</TD><TD> </TD></TR><TR><TD CLASS="l">159</TD><TD>    private DateConverter()</TD></TR><TR CLASS="z"><TD CLASS="l">160</TD><TD>    {</TD></TR><TR><TD CLASS="l">161</TD><TD>        //utility class should not be constructed.</TD></TR><TR CLASS="z"><TD CLASS="l">162</TD><TD>    }</TD></TR><TR><TD CLASS="l">163</TD><TD> </TD></TR><TR><TD CLASS="l">164</TD><TD>    ////////////////////////////////////////////</TD></TR><TR><TD CLASS="l">165</TD><TD>    // C o n v e r t   t o   S t r i n g   Methods</TD></TR><TR><TD CLASS="l">166</TD><TD>     </TD></TR><TR><TD CLASS="l">167</TD><TD>    /**</TD></TR><TR><TD CLASS="l">168</TD><TD>     * Get all know formats.</TD></TR><TR><TD CLASS="l">169</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="2">170</A></TD><TD>     * @return an array containig all known formats</TD></TR><TR><TD CLASS="l">171</TD><TD>     */</TD></TR><TR><TD CLASS="l">172</TD><TD>    public static String[] getFormats() </TD></TR><TR><TD CLASS="l">173</TD><TD>    {</TD></TR><TR CLASS="z"><TD CLASS="l">174</TD><TD>        String[] val = new String[ALPHA_START_FORMATS.length+DIGIT_START_FORMATS.length];</TD></TR><TR CLASS="z"><TD CLASS="l">175</TD><TD>        System.arraycopy(ALPHA_START_FORMATS, 0, val, 0, ALPHA_START_FORMATS.length);</TD></TR><TR CLASS="z"><TD CLASS="l">176</TD><TD>        System.arraycopy(DIGIT_START_FORMATS, 0, val,ALPHA_START_FORMATS.length, DIGIT_START_FORMATS.length);</TD></TR><TR CLASS="z"><TD CLASS="l">177</TD><TD>        return val;</TD></TR><TR><TD CLASS="l">178</TD><TD>    }</TD></TR><TR><TD CLASS="l">179</TD><TD> </TD></TR><TR><TD CLASS="l">180</TD><TD>    /**</TD></TR><TR><TD CLASS="l">181</TD><TD>     * Converts a Calendar to a string formatted as:</TD></TR><TR><TD CLASS="l">182</TD><TD>     *     D:yyyyMMddHHmmss#hh'mm'  where # is Z, +, or -.</TD></TR><TR><TD CLASS="l">183</TD><TD>     * </TD></TR><TR><TD CLASS="l">184</TD><TD>     * @param cal The date to convert to a string. May be null.</TD></TR><TR><TD CLASS="l">185</TD><TD>     * The DST_OFFSET is included when computing the output time zone.</TD></TR><TR><TD CLASS="l">186</TD><TD>     *</TD></TR><TR><TD CLASS="l">187</TD><TD>     * @return The date as a String to be used in a PDF document, </TD></TR><TR><TD CLASS="l"><A NAME="4">188</A></TD><TD>     *      or null if the cal value is null</TD></TR><TR><TD CLASS="l">189</TD><TD>     */</TD></TR><TR><TD CLASS="l">190</TD><TD>    public static String toString(Calendar cal)</TD></TR><TR><TD CLASS="l">191</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">192</TD><TD>        if (cal == null) </TD></TR><TR><TD CLASS="l">193</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">194</TD><TD>            return null;</TD></TR><TR><TD CLASS="l">195</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">196</TD><TD>        String offset = formatTZoffset(cal.get(Calendar.ZONE_OFFSET)</TD></TR><TR CLASS="c"><TD CLASS="l">197</TD><TD>                + cal.get(Calendar.DST_OFFSET), &#34;'&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">198</TD><TD>        return String.format(&#34;D:&#34;</TD></TR><TR><TD CLASS="l">199</TD><TD>                + &#34;%1$4tY%1$2tm%1$2td&#34;   // yyyyMMdd </TD></TR><TR><TD CLASS="l">200</TD><TD>                + &#34;%1$2tH%1$2tM%1$2tS&#34;   // HHmmss </TD></TR><TR><TD CLASS="l">201</TD><TD>                + &#34;%2$s&#34;                // time zone</TD></TR><TR><TD CLASS="l">202</TD><TD>                + &#34;'&#34;,                  // trailing apostrophe</TD></TR><TR><TD CLASS="l">203</TD><TD>            cal, offset);      </TD></TR><TR><TD CLASS="l">204</TD><TD>    }</TD></TR><TR><TD CLASS="l">205</TD><TD> </TD></TR><TR><TD CLASS="l">206</TD><TD>    /**</TD></TR><TR><TD CLASS="l">207</TD><TD>     * Converts the date to ISO 8601 string format:</TD></TR><TR><TD CLASS="l">208</TD><TD>     *     yyyy-mm-ddThh:MM:ss#hh:mm    (where '#&#34; is '+' or '-').</TD></TR><TR><TD CLASS="l">209</TD><TD>     *</TD></TR><TR><TD CLASS="l">210</TD><TD>     * @param cal The date to convert.  Must not be null.</TD></TR><TR><TD CLASS="l">211</TD><TD>     * The DST_OFFSET is included in the output value.</TD></TR><TR><TD CLASS="l">212</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="13">213</A></TD><TD>     * @return The date represented as an ISO 8601 string.</TD></TR><TR><TD CLASS="l">214</TD><TD>     */</TD></TR><TR><TD CLASS="l">215</TD><TD>    public static String toISO8601(Calendar cal)</TD></TR><TR><TD CLASS="l">216</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">217</TD><TD>        String offset = formatTZoffset(cal.get(Calendar.ZONE_OFFSET)</TD></TR><TR CLASS="c"><TD CLASS="l">218</TD><TD>                + cal.get(Calendar.DST_OFFSET), &#34;:&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">219</TD><TD>        return String.format(</TD></TR><TR><TD CLASS="l">220</TD><TD>                &#34;%1$4tY&#34;   // yyyy</TD></TR><TR><TD CLASS="l">221</TD><TD>                + &#34;-%1$2tm&#34;   // -mm  (%tm adds one to cal month value)</TD></TR><TR><TD CLASS="l">222</TD><TD>                + &#34;-%1$2td&#34;  // -dd  (%tm adds one to cal month value)</TD></TR><TR><TD CLASS="l">223</TD><TD>                + &#34;T&#34;                             // T</TD></TR><TR><TD CLASS="l">224</TD><TD>                + &#34;%1$2tH:%1$2tM:%1$2tS&#34;   // HHmmss  </TD></TR><TR><TD CLASS="l">225</TD><TD>                + &#34;%2$s&#34;,              // time zone</TD></TR><TR><TD CLASS="l">226</TD><TD>            cal, offset);      </TD></TR><TR><TD CLASS="l">227</TD><TD>    }</TD></TR><TR><TD CLASS="l">228</TD><TD>    </TD></TR><TR><TD CLASS="l">229</TD><TD>    /**</TD></TR><TR><TD CLASS="l">230</TD><TD>     * Constrain a timezone offset to the range  [-11:59 thru +11:59].</TD></TR><TR><TD CLASS="l">231</TD><TD>     * @param proposedOffset A value intended to be a timezone offset.</TD></TR><TR><TD CLASS="l">232</TD><TD>     * @return The corresponding value reduced to the above noted range </TD></TR><TR><TD CLASS="l"><A NAME="d">233</A></TD><TD>     * by adding or subtracting multiples of a full day.</TD></TR><TR><TD CLASS="l">234</TD><TD>     */</TD></TR><TR><TD CLASS="l">235</TD><TD>    public static int restrainTZoffset(long proposedOffset) </TD></TR><TR><TD CLASS="l">236</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">237</TD><TD>        proposedOffset = ((proposedOffset+HALF_DAY)%DAY+DAY)%DAY; </TD></TR><TR><TD CLASS="l">238</TD><TD>        // 0 &lt;= proposedOffset &lt; DAY</TD></TR><TR CLASS="c"><TD CLASS="l">239</TD><TD>        proposedOffset = (proposedOffset-HALF_DAY)%HALF_DAY;   </TD></TR><TR><TD CLASS="l">240</TD><TD>        // -HALF_DAY &lt; proposedOffset &lt; HALF_DAY</TD></TR><TR CLASS="c"><TD CLASS="l">241</TD><TD>        return (int)proposedOffset;</TD></TR><TR><TD CLASS="l">242</TD><TD>    }</TD></TR><TR><TD CLASS="l">243</TD><TD>    </TD></TR><TR><TD CLASS="l">244</TD><TD>    /** </TD></TR><TR><TD CLASS="l">245</TD><TD>     * Formats a time zone offset as #hh^mm</TD></TR><TR><TD CLASS="l">246</TD><TD>     * where # is + or -, hh is hours, ^ is a separator, and mm is minutes.</TD></TR><TR><TD CLASS="l">247</TD><TD>     * Any separator may be specified by the second argument;</TD></TR><TR><TD CLASS="l">248</TD><TD>     * the usual values are &#34;:&#34; (ISO 8601), &#34;&#34; (RFC 822), and &#34;'&#34; (PDF).</TD></TR><TR><TD CLASS="l">249</TD><TD>     * The returned value is constrained to the range -11:59 ... 11:59.</TD></TR><TR><TD CLASS="l">250</TD><TD>     * For offset of 0 millis, the String returned is &#34;+00^00&#34;, never &#34;Z&#34;.</TD></TR><TR><TD CLASS="l">251</TD><TD>     * To get a &#34;general&#34; offset in form GMT#hh:mm, write</TD></TR><TR><TD CLASS="l">252</TD><TD>     *      &#34;GMT&#34;+DateConverter.formatTZoffset(offset, &#34;:&#34;);</TD></TR><TR><TD CLASS="l">253</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">254</TD><TD>     * Take thought in choosing the source for the millis value. </TD></TR><TR><TD CLASS="l">255</TD><TD>     * It can come from calendarValue.getTimeZone() or from </TD></TR><TR><TD CLASS="l">256</TD><TD>     * calendarValue.get(Calendar.ZONE_OFFSET).  If a TimeZone was created</TD></TR><TR><TD CLASS="l">257</TD><TD>     * from a valid time zone ID, then it may have a daylight savings rule.</TD></TR><TR><TD CLASS="l">258</TD><TD>     * (As of July 4, 2013, the data base at http://www.iana.org/time-zones </TD></TR><TR><TD CLASS="l">259</TD><TD>     * recognized 629 time zone regions. But a TimeZone created as </TD></TR><TR><TD CLASS="l">260</TD><TD>     *      new SimpleTimeZone(millisOffset, &#34;ID&#34;), </TD></TR><TR><TD CLASS="l">261</TD><TD>     * will not have a daylight savings rule. (Not even if there is a</TD></TR><TR><TD CLASS="l">262</TD><TD>     * known time zone with the given ID. To get the TimeZone named &#34;xDT&#34;</TD></TR><TR><TD CLASS="l">263</TD><TD>     * with its DST rule, use an ID of EST5EDT, CST6CDT, MST7MDT, or PST8PDT.</TD></TR><TR><TD CLASS="l">264</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">265</TD><TD>     * When parsing PDF dates, the incoming values DOES NOT have a TIMEZONE value.</TD></TR><TR><TD CLASS="l">266</TD><TD>     * At most it has an OFFSET value like -04'00'. It is generally impossible to </TD></TR><TR><TD CLASS="l">267</TD><TD>     * determine what TIMEZONE corresponds to a given OFFSET. If the date is</TD></TR><TR><TD CLASS="l">268</TD><TD>     * in the summer when daylight savings is in effect, an offset of -0400</TD></TR><TR><TD CLASS="l">269</TD><TD>     * might correspond to any one of the 38 regions (of 53) with standard time </TD></TR><TR><TD CLASS="l">270</TD><TD>     * offset -0400 and no daylight saving. Or it might correspond to </TD></TR><TR><TD CLASS="l">271</TD><TD>     * any one of the 31 regions (out of 43) that observe daylight savings </TD></TR><TR><TD CLASS="l">272</TD><TD>     * and have standard time offset of -0500.</TD></TR><TR><TD CLASS="l">273</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">274</TD><TD>     * If a Calendar has not been assigned a TimeZone with setTimeZone(), </TD></TR><TR><TD CLASS="l">275</TD><TD>     * it will have by default the local TIMEZONE, not just the OFFSET.  In the</TD></TR><TR><TD CLASS="l">276</TD><TD>     * USA, this TimeZone will have a daylight savings rule.</TD></TR><TR><TD CLASS="l">277</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">278</TD><TD>     * The offset assigned with calVal.set(Calendar.ZONE_OFFSET) differs</TD></TR><TR><TD CLASS="l">279</TD><TD>     * from the offset in the TimeZone set by Calendar.setTimeZone(). Example:</TD></TR><TR><TD CLASS="l">280</TD><TD>     * Suppose my local TimeZone is America/New_York. It has an offset of -05'00'.</TD></TR><TR><TD CLASS="l">281</TD><TD>     * And suppose I set a GregorianCalendar's ZONE_OFFSET to -07'00'</TD></TR><TR><TD CLASS="l">282</TD><TD>     *     calVal = new GregorianCalendar();   // TimeZone is the local default</TD></TR><TR><TD CLASS="l">283</TD><TD>     *     calVal.set(Calendar.ZONE_OFFSET, -7* MILLIS_PER_HOUR);</TD></TR><TR><TD CLASS="l">284</TD><TD>     * Four different offsets can be computed from calVal:</TD></TR><TR><TD CLASS="l">285</TD><TD>     *     calVal.get(Calendar.ZONE_OFFSET)  =&gt;  -07:00</TD></TR><TR><TD CLASS="l">286</TD><TD>     *     calVal.get(Calendar.ZONE_OFFSET) + calVal.get(Calendar.DST_OFFSET) =&gt; -06:00</TD></TR><TR><TD CLASS="l">287</TD><TD>     *     calVal.getTimeZone().getRawOffset()  =&gt;  -05:00</TD></TR><TR><TD CLASS="l">288</TD><TD>     *     calVal.getTimeZone().getOffset(calVal.getTimeInMillis())  =&gt;  -04:00</TD></TR><TR><TD CLASS="l">289</TD><TD>     * &lt;p&gt;</TD></TR><TR><TD CLASS="l">290</TD><TD>     * Which is correct??? I dunno, though setTimeZone() does seem to affect</TD></TR><TR><TD CLASS="l">291</TD><TD>     * ZONE_OFFSET, and not vice versa.  One cannot even test whether TimeZone </TD></TR><TR><TD CLASS="l">292</TD><TD>     * or ZONE_OFFSET has been set; both have been set by initialization code.</TD></TR><TR><TD CLASS="l">293</TD><TD>     * TimeZone is initialized to the local default time zone </TD></TR><TR><TD CLASS="l">294</TD><TD>     * and ZONE_OFFSET is set from it.</TD></TR><TR><TD CLASS="l">295</TD><TD>     * </TD></TR><TR><TD CLASS="l">296</TD><TD>     * My choice in this DateConverter class has been to set the </TD></TR><TR><TD CLASS="l">297</TD><TD>     * initial TimeZone of a GregorianCalendar to GMT. Thereafter</TD></TR><TR><TD CLASS="l">298</TD><TD>     * the TimeZone is modified with {@link #adjustTimeZoneNicely}. </TD></TR><TR><TD CLASS="l">299</TD><TD>     * </TD></TR><TR><TD CLASS="l">300</TD><TD>     * @param millis a time zone offset expressed in milliseconds</TD></TR><TR><TD CLASS="l">301</TD><TD>     *      Any value is accepted; it is normalized to [-11:59 ... +11:59]</TD></TR><TR><TD CLASS="l">302</TD><TD>     * @param sep a String to insert between hh and mm. May be empty.</TD></TR><TR><TD CLASS="l"><A NAME="9">303</A></TD><TD>     * @return the formatted String for the offset</TD></TR><TR><TD CLASS="l">304</TD><TD>     */</TD></TR><TR><TD CLASS="l">305</TD><TD>    public static String formatTZoffset(long millis, String sep) </TD></TR><TR><TD CLASS="l">306</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">307</TD><TD>        SimpleDateFormat sdf = new SimpleDateFormat(&#34;Z&#34;); // #hhmm</TD></TR><TR CLASS="c"><TD CLASS="l">308</TD><TD>        sdf.setTimeZone(new SimpleTimeZone(restrainTZoffset(millis),&#34;unknown&#34;));</TD></TR><TR CLASS="c"><TD CLASS="l">309</TD><TD>        String tz = sdf.format(new Date());</TD></TR><TR CLASS="c"><TD CLASS="l">310</TD><TD>        return tz.substring(0,3)+sep+tz.substring(3);</TD></TR><TR><TD CLASS="l">311</TD><TD>    }</TD></TR><TR><TD CLASS="l">312</TD><TD> </TD></TR><TR><TD CLASS="l">313</TD><TD>    //////////////////////////////////////////////</TD></TR><TR><TD CLASS="l">314</TD><TD>    // P A R S E   Methods</TD></TR><TR><TD CLASS="l">315</TD><TD> </TD></TR><TR><TD CLASS="l">316</TD><TD>     /**</TD></TR><TR><TD CLASS="l">317</TD><TD>     * Parses an integer from a string, starting at and advancing a ParsePosition.</TD></TR><TR><TD CLASS="l">318</TD><TD>     * </TD></TR><TR><TD CLASS="l">319</TD><TD>     * @param text The string being parsed. If null, the remedy value is returned.</TD></TR><TR><TD CLASS="l">320</TD><TD>     * @param where The ParsePosition to start the search. This value </TD></TR><TR><TD CLASS="l">321</TD><TD>     *      will be incremented by the number of digits found, but no </TD></TR><TR><TD CLASS="l">322</TD><TD>     *      more than maxlen.  That is, the ParsePosition will </TD></TR><TR><TD CLASS="l">323</TD><TD>     *      advance across at most maxlen initial digits in text.</TD></TR><TR><TD CLASS="l">324</TD><TD>     *      The error index is ignored and unchanged.</TD></TR><TR><TD CLASS="l">325</TD><TD>     * @param maxlen The maximum length of the integer to parse. </TD></TR><TR><TD CLASS="l">326</TD><TD>     *      Usually 2, but 4 for year fields.</TD></TR><TR><TD CLASS="l">327</TD><TD>     *      If the field of length maxlen begins with a digit, </TD></TR><TR><TD CLASS="l">328</TD><TD>     *      but contains a non-digit, no error is signaled </TD></TR><TR><TD CLASS="l">329</TD><TD>     *      and the integer value is returned.</TD></TR><TR><TD CLASS="l">330</TD><TD>     * @param remedy Value to be assigned if no digit is found at the</TD></TR><TR><TD CLASS="l">331</TD><TD>     *      initial parse position; that is, if the field is empty.</TD></TR><TR><TD CLASS="l">332</TD><TD>     * @return The integer that was at the given parse position. Or</TD></TR><TR><TD CLASS="l">333</TD><TD>     *      the remedy value if no digits were found.</TD></TR><TR><TD CLASS="l"><A NAME="6">334</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">335</TD><TD>    public static int parseTimeField(String text, ParsePosition where, </TD></TR><TR><TD CLASS="l">336</TD><TD>            int maxlen, int remedy) </TD></TR><TR><TD CLASS="l">337</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">338</TD><TD>        if (text == null) </TD></TR><TR><TD CLASS="l">339</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">340</TD><TD>                    return remedy; </TD></TR><TR><TD CLASS="l">341</TD><TD>        }</TD></TR><TR><TD CLASS="l">342</TD><TD>        // (it would seem that DecimalFormat.parse() would be simpler;</TD></TR><TR><TD CLASS="l">343</TD><TD>        //     but that class blithely ignores setMaximumIntegerDigits)</TD></TR><TR CLASS="c"><TD CLASS="l">344</TD><TD>        int retval = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">345</TD><TD>        int index = where.getIndex();</TD></TR><TR CLASS="c"><TD CLASS="l">346</TD><TD>        int limit = index + Math.min(maxlen, text.length()-index);</TD></TR><TR CLASS="c"><TD CLASS="l">347</TD><TD>        for (; index &lt; limit; index++)</TD></TR><TR><TD CLASS="l">348</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">349</TD><TD>            int cval = text.charAt(index) - '0';  // convert digit to integer</TD></TR><TR CLASS="c"><TD CLASS="l">350</TD><TD>            if (cval &lt;0 || cval &gt; 9)   // test to see if we got a digit</TD></TR><TR><TD CLASS="l">351</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">352</TD><TD>                break;   // no digit at index</TD></TR><TR><TD CLASS="l">353</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">354</TD><TD>            retval = retval*10 + cval;   // append the digit to the return value</TD></TR><TR><TD CLASS="l">355</TD><TD>        }   </TD></TR><TR CLASS="c"><TD CLASS="l">356</TD><TD>        if (index == where.getIndex())</TD></TR><TR><TD CLASS="l">357</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">358</TD><TD>            return remedy;</TD></TR><TR><TD CLASS="l">359</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">360</TD><TD>        where.setIndex(index);</TD></TR><TR CLASS="c"><TD CLASS="l">361</TD><TD>        return retval;</TD></TR><TR><TD CLASS="l">362</TD><TD>    }</TD></TR><TR><TD CLASS="l">363</TD><TD> </TD></TR><TR><TD CLASS="l">364</TD><TD>    /**</TD></TR><TR><TD CLASS="l">365</TD><TD>     * Advances the ParsePosition past any and all the characters </TD></TR><TR><TD CLASS="l">366</TD><TD>     *      that match those in the optionals list.</TD></TR><TR><TD CLASS="l">367</TD><TD>     *      In particular, a space will skip all spaces.</TD></TR><TR><TD CLASS="l">368</TD><TD>     * @param text The text to examine</TD></TR><TR><TD CLASS="l">369</TD><TD>     * @param where index to start looking. </TD></TR><TR><TD CLASS="l">370</TD><TD>     *      The value is incremented by the number of optionals found.</TD></TR><TR><TD CLASS="l">371</TD><TD>     *      The error index is ignored and unchanged.</TD></TR><TR><TD CLASS="l">372</TD><TD>     * @param optionals A String listing all the optional characters </TD></TR><TR><TD CLASS="l">373</TD><TD>     *      to be skipped.</TD></TR><TR><TD CLASS="l">374</TD><TD>     * @return The last non-space character passed over. </TD></TR><TR><TD CLASS="l">375</TD><TD>     *      Returns a space if no non-space character was found </TD></TR><TR><TD CLASS="l">376</TD><TD>     *      (even if space is not in the optionals list.)</TD></TR><TR><TD CLASS="l"><A NAME="e">377</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">378</TD><TD>    public static char skipOptionals(String text, ParsePosition where, </TD></TR><TR><TD CLASS="l">379</TD><TD>            String optionals) </TD></TR><TR><TD CLASS="l">380</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">381</TD><TD>        char retval = ' ', currch;</TD></TR><TR CLASS="c"><TD CLASS="l">382</TD><TD>        while (text != null &amp;&amp; where.getIndex() &lt; text.length() </TD></TR><TR CLASS="c"><TD CLASS="l">383</TD><TD>                &amp;&amp; optionals.indexOf(</TD></TR><TR CLASS="c"><TD CLASS="l">384</TD><TD>                        (currch=text.charAt(where.getIndex()))</TD></TR><TR><TD CLASS="l">385</TD><TD>                ) &gt;= 0) </TD></TR><TR><TD CLASS="l">386</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">387</TD><TD>            retval = (currch != ' ') ? currch : retval;</TD></TR><TR CLASS="c"><TD CLASS="l">388</TD><TD>            where.setIndex(where.getIndex() + 1);</TD></TR><TR><TD CLASS="l">389</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">390</TD><TD>        return retval;</TD></TR><TR><TD CLASS="l">391</TD><TD>    }</TD></TR><TR><TD CLASS="l">392</TD><TD>    </TD></TR><TR><TD CLASS="l">393</TD><TD>    /**</TD></TR><TR><TD CLASS="l">394</TD><TD>     * If the victim string is at the given position in the text,</TD></TR><TR><TD CLASS="l">395</TD><TD>     * this method advances the position past that string. </TD></TR><TR><TD CLASS="l">396</TD><TD>     * </TD></TR><TR><TD CLASS="l">397</TD><TD>     * @param text The text to examine</TD></TR><TR><TD CLASS="l">398</TD><TD>     * @param victim The string to look for</TD></TR><TR><TD CLASS="l">399</TD><TD>     * @param where The initial position to look at. After return, this will</TD></TR><TR><TD CLASS="l">400</TD><TD>     *      have been incremented by the length of the victim if it was found.</TD></TR><TR><TD CLASS="l">401</TD><TD>     *      The error index is ignored and unchanged.</TD></TR><TR><TD CLASS="l"><A NAME="f">402</A></TD><TD>     * @return true if victim was found; otherwise false.</TD></TR><TR><TD CLASS="l">403</TD><TD>     */</TD></TR><TR><TD CLASS="l">404</TD><TD>    public static boolean skipString(String text, String victim, ParsePosition where) </TD></TR><TR><TD CLASS="l">405</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">406</TD><TD>        if (text.startsWith(victim, where.getIndex()))</TD></TR><TR><TD CLASS="l">407</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">408</TD><TD>            where.setIndex(where.getIndex()+victim.length());</TD></TR><TR CLASS="c"><TD CLASS="l">409</TD><TD>            return true;</TD></TR><TR><TD CLASS="l">410</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">411</TD><TD>        return false;</TD></TR><TR><TD CLASS="l">412</TD><TD>    }</TD></TR><TR><TD CLASS="l">413</TD><TD> </TD></TR><TR><TD CLASS="l">414</TD><TD>    /** </TD></TR><TR><TD CLASS="l">415</TD><TD>     * Construct a new GregorianCalendar and set defaults.</TD></TR><TR><TD CLASS="l">416</TD><TD>     * Locale is ENGLISH.</TD></TR><TR><TD CLASS="l">417</TD><TD>     * TimeZone is &#34;UTC&#34; (zero offset and no DST).</TD></TR><TR><TD CLASS="l">418</TD><TD>     * Parsing is NOT lenient. Milliseconds are zero.</TD></TR><TR><TD CLASS="l">419</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="a">420</A></TD><TD>     * @return a new gregorian calendar</TD></TR><TR><TD CLASS="l">421</TD><TD>     */</TD></TR><TR><TD CLASS="l">422</TD><TD>    public static GregorianCalendar newGreg()  </TD></TR><TR><TD CLASS="l">423</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">424</TD><TD>        GregorianCalendar retCal = new GregorianCalendar(Locale.ENGLISH);</TD></TR><TR CLASS="c"><TD CLASS="l">425</TD><TD>        retCal.setTimeZone(new SimpleTimeZone(0, &#34;UTC&#34;));</TD></TR><TR CLASS="c"><TD CLASS="l">426</TD><TD>        retCal.setLenient(false);</TD></TR><TR CLASS="c"><TD CLASS="l">427</TD><TD>        retCal.set(Calendar.MILLISECOND, 0);</TD></TR><TR CLASS="c"><TD CLASS="l">428</TD><TD>        return retCal;</TD></TR><TR><TD CLASS="l">429</TD><TD>    }</TD></TR><TR><TD CLASS="l">430</TD><TD>    </TD></TR><TR><TD CLASS="l">431</TD><TD>    /**</TD></TR><TR><TD CLASS="l">432</TD><TD>     * Install a TimeZone on a GregorianCalendar without changing the </TD></TR><TR><TD CLASS="l">433</TD><TD>     * hours value. A plain GregorianCalendat.setTimeZone() </TD></TR><TR><TD CLASS="l">434</TD><TD>     * adjusts the Calendar.HOUR value to compensate. This is *BAD*</TD></TR><TR><TD CLASS="l">435</TD><TD>     * (not to say *EVIL*) when we have already set the time.</TD></TR><TR><TD CLASS="l">436</TD><TD>     * @param cal The GregorianCalendar whose TimeZone to change.</TD></TR><TR><TD CLASS="l"><A NAME="8">437</A></TD><TD>     * @param tz The new TimeZone.</TD></TR><TR><TD CLASS="l">438</TD><TD>     */</TD></TR><TR><TD CLASS="l">439</TD><TD>    public static void adjustTimeZoneNicely(GregorianCalendar cal, TimeZone tz) </TD></TR><TR><TD CLASS="l">440</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">441</TD><TD>        cal.setTimeZone(tz);</TD></TR><TR CLASS="c"><TD CLASS="l">442</TD><TD>        int offset = (cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / </TD></TR><TR><TD CLASS="l">443</TD><TD>                MILLIS_PER_MINUTE;</TD></TR><TR CLASS="c"><TD CLASS="l">444</TD><TD>        cal.add(Calendar.MINUTE, -offset);    }</TD></TR><TR><TD CLASS="l">445</TD><TD>    </TD></TR><TR><TD CLASS="l">446</TD><TD>    /**</TD></TR><TR><TD CLASS="l">447</TD><TD>     * Parses the end of a date string for a time zone and, if one is found,</TD></TR><TR><TD CLASS="l">448</TD><TD>     * sets the time zone of the GregorianCalendar. Otherwise the calendar </TD></TR><TR><TD CLASS="l">449</TD><TD>     * time zone is unchanged.</TD></TR><TR><TD CLASS="l">450</TD><TD>     * </TD></TR><TR><TD CLASS="l">451</TD><TD>     * The text is parsed as</TD></TR><TR><TD CLASS="l">452</TD><TD>     *      (Z|GMT|UTC)? [+- ]* h [': ]? m '?</TD></TR><TR><TD CLASS="l">453</TD><TD>     * where the leading String is optional, h is two digits by default, </TD></TR><TR><TD CLASS="l">454</TD><TD>     * but may be a single digit if followed by one of space, apostrophe, </TD></TR><TR><TD CLASS="l">455</TD><TD>     * colon, or the end of string. Similarly, m is one or two digits. </TD></TR><TR><TD CLASS="l">456</TD><TD>     * This scheme accepts the format of PDF, RFC 822, and ISO8601. </TD></TR><TR><TD CLASS="l">457</TD><TD>     * If none of these applies (as for a time zone name), we try</TD></TR><TR><TD CLASS="l">458</TD><TD>     * TimeZone.getTimeZone().</TD></TR><TR><TD CLASS="l">459</TD><TD>     * </TD></TR><TR><TD CLASS="l">460</TD><TD>     * @param text The text expected to begin with a time zone value,</TD></TR><TR><TD CLASS="l">461</TD><TD>     * possibly with leading or trailing spaces.</TD></TR><TR><TD CLASS="l">462</TD><TD>     * @param cal The Calendar whose TimeZone to set. </TD></TR><TR><TD CLASS="l">463</TD><TD>     * @param initialWhere where Scanning begins at where.index. After success, the returned</TD></TR><TR><TD CLASS="l">464</TD><TD>     *      index is that of the next character after the recognized string.</TD></TR><TR><TD CLASS="l">465</TD><TD>     *      The error index is ignored and unchanged.</TD></TR><TR><TD CLASS="l">466</TD><TD>     * @return true if parsed a time zone value; otherwise the </TD></TR><TR><TD CLASS="l">467</TD><TD>     *      time zone is unchanged and the return value is false.</TD></TR><TR><TD CLASS="l"><A NAME="c">468</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">469</TD><TD>    public static boolean parseTZoffset(String text, GregorianCalendar cal, </TD></TR><TR><TD CLASS="l">470</TD><TD>            ParsePosition initialWhere) </TD></TR><TR><TD CLASS="l">471</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">472</TD><TD>        ParsePosition where = new ParsePosition(initialWhere.getIndex());</TD></TR><TR CLASS="c"><TD CLASS="l">473</TD><TD>        TimeZone tz = new SimpleTimeZone(0, &#34;GMT&#34;);</TD></TR><TR><TD CLASS="l">474</TD><TD>        int tzHours, tzMin;</TD></TR><TR CLASS="c"><TD CLASS="l">475</TD><TD>        char sign = skipOptionals(text, where, &#34;Z+- &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">476</TD><TD>        boolean hadGMT = (sign == 'Z' || skipString(text, &#34;GMT&#34;, where) </TD></TR><TR CLASS="c"><TD CLASS="l">477</TD><TD>                || skipString(text, &#34;UTC&#34;, where));</TD></TR><TR CLASS="c"><TD CLASS="l">478</TD><TD>        sign = ( ! hadGMT) ? sign : skipOptionals(text, where, &#34;+- &#34;); </TD></TR><TR><TD CLASS="l">479</TD><TD>        </TD></TR><TR CLASS="c"><TD CLASS="l">480</TD><TD>        tzHours = parseTimeField(text, where, 2, -999);</TD></TR><TR CLASS="c"><TD CLASS="l">481</TD><TD>        skipOptionals(text, where, &#34;\': &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">482</TD><TD>        tzMin = parseTimeField(text, where, 2, 0);</TD></TR><TR CLASS="c"><TD CLASS="l">483</TD><TD>        skipOptionals(text, where, &#34;\' &#34;); </TD></TR><TR><TD CLASS="l">484</TD><TD>        </TD></TR><TR CLASS="c"><TD CLASS="l">485</TD><TD>        if (tzHours != -999) </TD></TR><TR><TD CLASS="l">486</TD><TD>        {                    // we parsed a time zone in default format</TD></TR><TR CLASS="c"><TD CLASS="l">487</TD><TD>            int hrSign = (sign == '-' ? -1 :+1);</TD></TR><TR CLASS="c"><TD CLASS="l">488</TD><TD>            tz.setRawOffset(restrainTZoffset(hrSign*(tzHours*MILLIS_PER_HOUR + tzMin*MILLIS_PER_MINUTE))); </TD></TR><TR CLASS="c"><TD CLASS="l">489</TD><TD>            tz.setID(&#34;unknown&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">490</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">491</TD><TD>        else if ( ! hadGMT)</TD></TR><TR><TD CLASS="l">492</TD><TD>        {            // try to process as a name; &#34;GMT&#34; or &#34;UTC&#34; has already been processed</TD></TR><TR CLASS="c"><TD CLASS="l">493</TD><TD>            String tzText = text.substring(initialWhere.getIndex()).trim();</TD></TR><TR CLASS="c"><TD CLASS="l">494</TD><TD>            tz = TimeZone.getTimeZone(tzText);</TD></TR><TR><TD CLASS="l">495</TD><TD>            // getTimeZone returns &#34;GMT&#34; for unknown ids</TD></TR><TR CLASS="c"><TD CLASS="l">496</TD><TD>            if (&#34;GMT&#34;.equals(tz.getID()))  </TD></TR><TR><TD CLASS="l">497</TD><TD>            {                // no timezone in text</TD></TR><TR><TD CLASS="l">498</TD><TD>                // cal amd initialWhere are unchanged</TD></TR><TR CLASS="c"><TD CLASS="l">499</TD><TD>                return false;</TD></TR><TR><TD CLASS="l">500</TD><TD>            }</TD></TR><TR><TD CLASS="l">501</TD><TD>            else</TD></TR><TR><TD CLASS="l">502</TD><TD>            {                // we got a tz by name; use it</TD></TR><TR CLASS="c"><TD CLASS="l">503</TD><TD>                where.setIndex(text.length());</TD></TR><TR><TD CLASS="l">504</TD><TD>            }</TD></TR><TR><TD CLASS="l">505</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">506</TD><TD>        adjustTimeZoneNicely(cal, tz);</TD></TR><TR CLASS="c"><TD CLASS="l">507</TD><TD>        initialWhere.setIndex(where.getIndex());</TD></TR><TR CLASS="c"><TD CLASS="l">508</TD><TD>        return true;</TD></TR><TR><TD CLASS="l">509</TD><TD>    }</TD></TR><TR><TD CLASS="l">510</TD><TD>    </TD></TR><TR><TD CLASS="l">511</TD><TD>    /**</TD></TR><TR><TD CLASS="l">512</TD><TD>     * Parses a big-endian date: year month day hour min sec.</TD></TR><TR><TD CLASS="l">513</TD><TD>     * The year must be four digits. Other fields may be adjacent </TD></TR><TR><TD CLASS="l">514</TD><TD>     * and delimited by length or they may follow appropriate delimiters.</TD></TR><TR><TD CLASS="l">515</TD><TD>     *     year [ -/]* month [ -/]* dayofmonth [ T]* hour [:] min [:] sec [.secFraction]</TD></TR><TR><TD CLASS="l">516</TD><TD>     * If any numeric field is omitted, all following fields must also be omitted.</TD></TR><TR><TD CLASS="l">517</TD><TD>     * No time zone is processed.</TD></TR><TR><TD CLASS="l">518</TD><TD>     * </TD></TR><TR><TD CLASS="l">519</TD><TD>     * Ambiguous dates can produce unexpected results. For example:</TD></TR><TR><TD CLASS="l">520</TD><TD>     *      1970 12 23:08 will parse as 1970 December 23 00:08:00 </TD></TR><TR><TD CLASS="l">521</TD><TD>     * </TD></TR><TR><TD CLASS="l">522</TD><TD>     * @param text The string to parse.</TD></TR><TR><TD CLASS="l">523</TD><TD>     * </TD></TR><TR><TD CLASS="l">524</TD><TD>     * @param initialWhere Where to begin the parse. On return the index</TD></TR><TR><TD CLASS="l">525</TD><TD>     *      is advanced to just beyond the last character processed.</TD></TR><TR><TD CLASS="l">526</TD><TD>     *      The error index is ignored and unchanged.</TD></TR><TR><TD CLASS="l">527</TD><TD>     * </TD></TR><TR><TD CLASS="l">528</TD><TD>     * @return a GregorianCalendar representing the parsed date. </TD></TR><TR><TD CLASS="l">529</TD><TD>     *      Or null if the text did not begin with at least four digits.</TD></TR><TR><TD CLASS="l"><A NAME="5">530</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">531</TD><TD>    public static GregorianCalendar parseBigEndianDate(String text, </TD></TR><TR><TD CLASS="l">532</TD><TD>            ParsePosition initialWhere) </TD></TR><TR><TD CLASS="l">533</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">534</TD><TD>        ParsePosition where = new ParsePosition(initialWhere.getIndex());</TD></TR><TR CLASS="c"><TD CLASS="l">535</TD><TD>        int year = parseTimeField(text, where, 4, 0);</TD></TR><TR CLASS="c"><TD CLASS="l">536</TD><TD>        if (where.getIndex() != 4 + initialWhere.getIndex()) </TD></TR><TR><TD CLASS="l">537</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">538</TD><TD>            return null;</TD></TR><TR><TD CLASS="l">539</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">540</TD><TD>        skipOptionals(text, where, &#34;/- &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">541</TD><TD>        int month = parseTimeField(text, where, 2, 1) - 1; // Calendar months are 0...11</TD></TR><TR CLASS="c"><TD CLASS="l">542</TD><TD>        skipOptionals(text, where, &#34;/- &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">543</TD><TD>        int day = parseTimeField(text, where, 2, 1);</TD></TR><TR CLASS="c"><TD CLASS="l">544</TD><TD>        skipOptionals(text, where, &#34; T&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">545</TD><TD>        int hour = parseTimeField(text, where, 2, 0);</TD></TR><TR CLASS="c"><TD CLASS="l">546</TD><TD>        skipOptionals(text, where, &#34;: &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">547</TD><TD>        int minute = parseTimeField(text, where, 2, 0);</TD></TR><TR CLASS="c"><TD CLASS="l">548</TD><TD>        skipOptionals(text, where, &#34;: &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">549</TD><TD>        int second = parseTimeField(text, where, 2, 0);</TD></TR><TR CLASS="c"><TD CLASS="l">550</TD><TD>        char nextC = skipOptionals(text, where, &#34;.&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">551</TD><TD>        if (nextC == '.')</TD></TR><TR><TD CLASS="l">552</TD><TD>        {</TD></TR><TR><TD CLASS="l">553</TD><TD>            // fractions of a second: skip upto 19 digits</TD></TR><TR CLASS="z"><TD CLASS="l">554</TD><TD>            parseTimeField(text, where, 19, 0);</TD></TR><TR><TD CLASS="l">555</TD><TD>        }</TD></TR><TR><TD CLASS="l">556</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">557</TD><TD>        GregorianCalendar dest = newGreg();</TD></TR><TR><TD CLASS="l">558</TD><TD>        try </TD></TR><TR><TD CLASS="l">559</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">560</TD><TD>            dest.set(year, month, day, hour, minute, second);</TD></TR><TR CLASS="c"><TD CLASS="l">561</TD><TD>            dest.getTimeInMillis();    // trigger limit tests</TD></TR><TR><TD CLASS="l">562</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">563</TD><TD>        catch (IllegalArgumentException ill) </TD></TR><TR><TD CLASS="l">564</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">565</TD><TD>            return  null;</TD></TR><TR CLASS="c"><TD CLASS="l">566</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">567</TD><TD>        initialWhere.setIndex(where.getIndex());</TD></TR><TR CLASS="c"><TD CLASS="l">568</TD><TD>        skipOptionals(text, initialWhere, &#34; &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">569</TD><TD>        return dest;    // dest has at least a year value</TD></TR><TR><TD CLASS="l">570</TD><TD>    }</TD></TR><TR><TD CLASS="l">571</TD><TD> </TD></TR><TR><TD CLASS="l">572</TD><TD>    /**</TD></TR><TR><TD CLASS="l">573</TD><TD>     * See if text can be parsed as a date according to any of a list of </TD></TR><TR><TD CLASS="l">574</TD><TD>     * formats. The time zone may be included as part of the format, or</TD></TR><TR><TD CLASS="l">575</TD><TD>     * omitted in favor of later testing for a trailing time zone.</TD></TR><TR><TD CLASS="l">576</TD><TD>     * </TD></TR><TR><TD CLASS="l">577</TD><TD>     * @param text The text to be parsed.</TD></TR><TR><TD CLASS="l">578</TD><TD>     * </TD></TR><TR><TD CLASS="l">579</TD><TD>     * @param fmts A list of formats to be tried. The syntax is that for </TD></TR><TR><TD CLASS="l">580</TD><TD>     *      {@link java.text.SimpleDateFormat}</TD></TR><TR><TD CLASS="l">581</TD><TD>     * </TD></TR><TR><TD CLASS="l">582</TD><TD>     * @param initialWhere At start this is the position to begin</TD></TR><TR><TD CLASS="l">583</TD><TD>     *      examining the text. Upon return it will have been</TD></TR><TR><TD CLASS="l">584</TD><TD>     *      incremented to refer to the next non-space character after the date.</TD></TR><TR><TD CLASS="l">585</TD><TD>     *      If no date was found, the value is unchanged.</TD></TR><TR><TD CLASS="l">586</TD><TD>     *      The error index is ignored and unchanged.</TD></TR><TR><TD CLASS="l">587</TD><TD>     * </TD></TR><TR><TD CLASS="l">588</TD><TD>     * @return null for failure to find a date, or the GregorianCalendar</TD></TR><TR><TD CLASS="l">589</TD><TD>     *      for the date that was found. Unless a time zone was </TD></TR><TR><TD CLASS="l">590</TD><TD>     *      part of the format, the time zone will be GMT+0</TD></TR><TR><TD CLASS="l"><A NAME="b">591</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">592</TD><TD>    public static GregorianCalendar parseSimpleDate(String text, String[] fmts, </TD></TR><TR><TD CLASS="l">593</TD><TD>            ParsePosition initialWhere) </TD></TR><TR><TD CLASS="l">594</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">595</TD><TD>        for(String fmt : fmts)</TD></TR><TR><TD CLASS="l">596</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">597</TD><TD>            ParsePosition where = new ParsePosition(initialWhere.getIndex());</TD></TR><TR CLASS="c"><TD CLASS="l">598</TD><TD>            SimpleDateFormat sdf = new SimpleDateFormat(fmt, Locale.ENGLISH);</TD></TR><TR CLASS="c"><TD CLASS="l">599</TD><TD>            GregorianCalendar retCal = newGreg();</TD></TR><TR CLASS="c"><TD CLASS="l">600</TD><TD>            sdf.setCalendar(retCal);</TD></TR><TR CLASS="c"><TD CLASS="l">601</TD><TD>            if (sdf.parse(text, where) != null)</TD></TR><TR><TD CLASS="l">602</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">603</TD><TD>                initialWhere.setIndex(where.getIndex());</TD></TR><TR CLASS="c"><TD CLASS="l">604</TD><TD>                skipOptionals(text, initialWhere, &#34; &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">605</TD><TD>                return retCal;</TD></TR><TR><TD CLASS="l">606</TD><TD>            }</TD></TR><TR><TD CLASS="l">607</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">608</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">609</TD><TD>    }</TD></TR><TR><TD CLASS="l">610</TD><TD> </TD></TR><TR><TD CLASS="l">611</TD><TD>    </TD></TR><TR><TD CLASS="l">612</TD><TD>    /**</TD></TR><TR><TD CLASS="l">613</TD><TD>     * Parses a String to see if it begins with a date, and if so, </TD></TR><TR><TD CLASS="l">614</TD><TD>     * returns that date. The date must be strictly correct--no </TD></TR><TR><TD CLASS="l">615</TD><TD>     * field may exceed the appropriate limit.</TD></TR><TR><TD CLASS="l">616</TD><TD>     * (That is, the Calendar has setLenient(false).) </TD></TR><TR><TD CLASS="l">617</TD><TD>     * Skips initial spaces, but does NOT check for &#34;D:&#34;</TD></TR><TR><TD CLASS="l">618</TD><TD>     * </TD></TR><TR><TD CLASS="l">619</TD><TD>     * The scan first tries parseBigEndianDate and parseTZoffset</TD></TR><TR><TD CLASS="l">620</TD><TD>     * and then tries parseSimpleDate with appropriate formats, </TD></TR><TR><TD CLASS="l">621</TD><TD>     * again followed by parseTZoffset. If at any stage the entire </TD></TR><TR><TD CLASS="l">622</TD><TD>     * text is consumed, that date value is returned immediately. </TD></TR><TR><TD CLASS="l">623</TD><TD>     * Otherwise the date that consumes the longest initial part</TD></TR><TR><TD CLASS="l">624</TD><TD>     * of the text is returned.</TD></TR><TR><TD CLASS="l">625</TD><TD>     * </TD></TR><TR><TD CLASS="l">626</TD><TD>     * - PDF format dates are among those recognized by parseBigEndianDate.</TD></TR><TR><TD CLASS="l">627</TD><TD>     * - The formats tried are alphaStartFormats or digitStartFormat and</TD></TR><TR><TD CLASS="l">628</TD><TD>     * any listed in the value of moreFmts.</TD></TR><TR><TD CLASS="l">629</TD><TD>     * </TD></TR><TR><TD CLASS="l">630</TD><TD>     * @param text The String that may begin with a date. Must not be null.</TD></TR><TR><TD CLASS="l">631</TD><TD>     *      Initial spaces and &#34;D:&#34; are skipped over.</TD></TR><TR><TD CLASS="l">632</TD><TD>     * @param moreFmts Additional formats to be tried after trying the</TD></TR><TR><TD CLASS="l">633</TD><TD>     *      built-in formats.</TD></TR><TR><TD CLASS="l">634</TD><TD>     * @param initialWhere where Parsing begins at the given position in text. If the</TD></TR><TR><TD CLASS="l">635</TD><TD>     *      parse succeeds, the index of where is advanced to point </TD></TR><TR><TD CLASS="l">636</TD><TD>     *      to the first unrecognized character.</TD></TR><TR><TD CLASS="l">637</TD><TD>     *      The error index is ignored and unchanged.</TD></TR><TR><TD CLASS="l">638</TD><TD>     * @return A GregorianCalendar for the date. If no date is found, </TD></TR><TR><TD CLASS="l">639</TD><TD>     *      returns null. The time zone will be GMT+0 unless parsing </TD></TR><TR><TD CLASS="l">640</TD><TD>     *      succeeded with a format containing a time zone. (Only one</TD></TR><TR><TD CLASS="l">641</TD><TD>     *      builtin format contains a time zone.)</TD></TR><TR><TD CLASS="l">642</TD><TD>     * </TD></TR><TR><TD CLASS="l">643</TD><TD>     */</TD></TR><TR><TD CLASS="l"><A NAME="3">644</A></TD><TD>    public static Calendar parseDate(String text, String[] moreFmts, </TD></TR><TR><TD CLASS="l">645</TD><TD>            ParsePosition initialWhere) </TD></TR><TR><TD CLASS="l">646</TD><TD>    {</TD></TR><TR><TD CLASS="l">647</TD><TD>        // place to remember longestr date string</TD></TR><TR CLASS="c"><TD CLASS="l">648</TD><TD>        int longestLen = -999999;  // theorem: this value will never be used</TD></TR><TR><TD CLASS="l">649</TD><TD>                // proof: longestLen is only used if longestDate is not null</TD></TR><TR CLASS="c"><TD CLASS="l">650</TD><TD>        GregorianCalendar longestDate = null; // null says no date found yet</TD></TR><TR><TD CLASS="l">651</TD><TD>        int whereLen;   // tempcopy of where.getIndex()</TD></TR><TR><TD CLASS="l">652</TD><TD>        </TD></TR><TR CLASS="c"><TD CLASS="l">653</TD><TD>        ParsePosition where = new ParsePosition(initialWhere.getIndex());</TD></TR><TR><TD CLASS="l">654</TD><TD>        // check for null (throws exception) and trim off surrounding spaces</TD></TR><TR CLASS="c"><TD CLASS="l">655</TD><TD>        skipOptionals(text, where, &#34; &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">656</TD><TD>        int startPosition = where.getIndex();</TD></TR><TR><TD CLASS="l">657</TD><TD> </TD></TR><TR><TD CLASS="l">658</TD><TD>        // try big-endian parse</TD></TR><TR CLASS="c"><TD CLASS="l">659</TD><TD>        GregorianCalendar retCal = parseBigEndianDate(text, where);</TD></TR><TR><TD CLASS="l">660</TD><TD>        // check for success and a timezone</TD></TR><TR CLASS="c"><TD CLASS="l">661</TD><TD>        if (retCal != null &amp;&amp;</TD></TR><TR CLASS="c"><TD CLASS="l">662</TD><TD>                (where.getIndex() == text.length() </TD></TR><TR CLASS="c"><TD CLASS="l">663</TD><TD>                || parseTZoffset(text, retCal, where))) </TD></TR><TR><TD CLASS="l">664</TD><TD>        {</TD></TR><TR><TD CLASS="l">665</TD><TD>            // if text is fully consumed, return the date</TD></TR><TR><TD CLASS="l">666</TD><TD>            // else remember it and its length</TD></TR><TR CLASS="c"><TD CLASS="l">667</TD><TD>            whereLen = where.getIndex();</TD></TR><TR CLASS="c"><TD CLASS="l">668</TD><TD>            if (whereLen == text.length()) </TD></TR><TR><TD CLASS="l">669</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">670</TD><TD>                initialWhere.setIndex(whereLen);</TD></TR><TR CLASS="c"><TD CLASS="l">671</TD><TD>                return retCal;</TD></TR><TR><TD CLASS="l">672</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">673</TD><TD>            longestLen = whereLen;</TD></TR><TR CLASS="c"><TD CLASS="l">674</TD><TD>            longestDate = retCal;</TD></TR><TR><TD CLASS="l">675</TD><TD>        }</TD></TR><TR><TD CLASS="l">676</TD><TD> </TD></TR><TR><TD CLASS="l">677</TD><TD>        // try one of the sets of standard formats</TD></TR><TR CLASS="c"><TD CLASS="l">678</TD><TD>        where.setIndex(startPosition);</TD></TR><TR CLASS="c"><TD CLASS="l">679</TD><TD>        String [] formats </TD></TR><TR CLASS="c"><TD CLASS="l">680</TD><TD>                = Character.isDigit(text.charAt(startPosition))</TD></TR><TR><TD CLASS="l">681</TD><TD>                ? DIGIT_START_FORMATS</TD></TR><TR><TD CLASS="l">682</TD><TD>                : ALPHA_START_FORMATS;</TD></TR><TR CLASS="c"><TD CLASS="l">683</TD><TD>        retCal = parseSimpleDate(text, formats, where);</TD></TR><TR><TD CLASS="l">684</TD><TD>        // check for success and a timezone</TD></TR><TR CLASS="c"><TD CLASS="l">685</TD><TD>        if (retCal != null &amp;&amp; </TD></TR><TR CLASS="c"><TD CLASS="l">686</TD><TD>                (where.getIndex() == text.length() </TD></TR><TR CLASS="c"><TD CLASS="l">687</TD><TD>                || parseTZoffset(text, retCal, where)))</TD></TR><TR><TD CLASS="l">688</TD><TD>        {</TD></TR><TR><TD CLASS="l">689</TD><TD>            // if text is fully consumed, return the date</TD></TR><TR><TD CLASS="l">690</TD><TD>            // else remember it and its length</TD></TR><TR CLASS="c"><TD CLASS="l">691</TD><TD>            whereLen = where.getIndex();</TD></TR><TR CLASS="c"><TD CLASS="l">692</TD><TD>            if (whereLen == text.length()) </TD></TR><TR><TD CLASS="l">693</TD><TD>            {</TD></TR><TR CLASS="c"><TD CLASS="l">694</TD><TD>                initialWhere.setIndex(whereLen);</TD></TR><TR CLASS="c"><TD CLASS="l">695</TD><TD>                return retCal;</TD></TR><TR><TD CLASS="l">696</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">697</TD><TD>            if (whereLen &gt; longestLen) </TD></TR><TR><TD CLASS="l">698</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">699</TD><TD>                longestLen = whereLen;</TD></TR><TR CLASS="z"><TD CLASS="l">700</TD><TD>                longestDate = retCal;</TD></TR><TR><TD CLASS="l">701</TD><TD>            }</TD></TR><TR><TD CLASS="l">702</TD><TD>        }</TD></TR><TR><TD CLASS="l">703</TD><TD>        </TD></TR><TR><TD CLASS="l">704</TD><TD>        // try the supplied formats</TD></TR><TR CLASS="c"><TD CLASS="l">705</TD><TD>        if (moreFmts != null)</TD></TR><TR><TD CLASS="l">706</TD><TD>        {</TD></TR><TR CLASS="z"><TD CLASS="l">707</TD><TD>            where.setIndex(startPosition);</TD></TR><TR CLASS="z"><TD CLASS="l">708</TD><TD>            retCal = parseSimpleDate(text, moreFmts, where);</TD></TR><TR CLASS="z"><TD CLASS="l">709</TD><TD>            if (retCal != null &amp;&amp; </TD></TR><TR CLASS="z"><TD CLASS="l">710</TD><TD>                (where.getIndex() == text.length() </TD></TR><TR CLASS="z"><TD CLASS="l">711</TD><TD>                || parseTZoffset(text, retCal, where)))</TD></TR><TR><TD CLASS="l">712</TD><TD>            {</TD></TR><TR CLASS="z"><TD CLASS="l">713</TD><TD>                whereLen = where.getIndex();</TD></TR><TR><TD CLASS="l">714</TD><TD>                // if text is fully consumed, return the date</TD></TR><TR><TD CLASS="l">715</TD><TD>                // else remember it and its length</TD></TR><TR CLASS="z"><TD CLASS="l">716</TD><TD>                if (whereLen == text.length() || </TD></TR><TR><TD CLASS="l">717</TD><TD>                        (longestDate != null &amp;&amp; whereLen &gt; longestLen)) </TD></TR><TR><TD CLASS="l">718</TD><TD>                {</TD></TR><TR CLASS="z"><TD CLASS="l">719</TD><TD>                    initialWhere.setIndex(whereLen);</TD></TR><TR CLASS="z"><TD CLASS="l">720</TD><TD>                    return retCal;</TD></TR><TR><TD CLASS="l">721</TD><TD>                }</TD></TR><TR><TD CLASS="l">722</TD><TD>            }</TD></TR><TR><TD CLASS="l">723</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">724</TD><TD>        if (longestDate != null) </TD></TR><TR><TD CLASS="l">725</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">726</TD><TD>            initialWhere.setIndex(longestLen);</TD></TR><TR CLASS="c"><TD CLASS="l">727</TD><TD>            return longestDate;</TD></TR><TR><TD CLASS="l">728</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">729</TD><TD>        return retCal;</TD></TR><TR><TD CLASS="l">730</TD><TD>    }</TD></TR><TR><TD CLASS="l">731</TD><TD>       </TD></TR><TR><TD CLASS="l">732</TD><TD>    /**</TD></TR><TR><TD CLASS="l">733</TD><TD>     * Converts a string to a Calendar by parsing the String for a date.</TD></TR><TR><TD CLASS="l">734</TD><TD>     * @see #toCalendar(String).</TD></TR><TR><TD CLASS="l">735</TD><TD>     *</TD></TR><TR><TD CLASS="l">736</TD><TD>     * The returned value will have 0 for DST_OFFSET.</TD></TR><TR><TD CLASS="l">737</TD><TD>     * </TD></TR><TR><TD CLASS="l">738</TD><TD>     * @param text The COSString representation of a date.</TD></TR><TR><TD CLASS="l">739</TD><TD>     * @return The Calendar that the text string represents. </TD></TR><TR><TD CLASS="l">740</TD><TD>     *      Or null if text was null.</TD></TR><TR><TD CLASS="l">741</TD><TD>     * @throws IOException If the date string is not in the correct format.</TD></TR><TR><TD CLASS="l">742</TD><TD>     * @deprecated This method throws an IOException for failure. Replace</TD></TR><TR><TD CLASS="l">743</TD><TD>     *      calls to it with {@link #toCalendar(String, String[])}</TD></TR><TR><TD CLASS="l">744</TD><TD>     *      and test for failure with</TD></TR><TR><TD CLASS="l"><A NAME="10">745</A></TD><TD>     *          (value == null || value.get(Calendar.YEAR) == INVALID_YEAR)</TD></TR><TR><TD CLASS="l">746</TD><TD>     */</TD></TR><TR><TD CLASS="l">747</TD><TD>    public static Calendar toCalendar(COSString text) throws IOException</TD></TR><TR><TD CLASS="l">748</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">749</TD><TD>        if (text == null)</TD></TR><TR><TD CLASS="l">750</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">751</TD><TD>            return null;    </TD></TR><TR><TD CLASS="l">752</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">753</TD><TD>        return toCalendar(text.getString());</TD></TR><TR><TD CLASS="l">754</TD><TD>    }</TD></TR><TR><TD CLASS="l">755</TD><TD>    </TD></TR><TR><TD CLASS="l">756</TD><TD>    /**</TD></TR><TR><TD CLASS="l">757</TD><TD>     * Converts a string date to a Calendar date value; equivalent to </TD></TR><TR><TD CLASS="l">758</TD><TD>     * {@link #toCalendar(String, String[])} using &lt;pre&gt;null&lt;/pre&gt; for the second parameter,</TD></TR><TR><TD CLASS="l">759</TD><TD>     * but throws an IOException for failure.</TD></TR><TR><TD CLASS="l">760</TD><TD>     * </TD></TR><TR><TD CLASS="l">761</TD><TD>     * The returned value will have 0 for DST_OFFSET.</TD></TR><TR><TD CLASS="l">762</TD><TD>     * </TD></TR><TR><TD CLASS="l">763</TD><TD>     * @param text The string representation of the calendar.</TD></TR><TR><TD CLASS="l">764</TD><TD>     * @return The Calendar that this string represents </TD></TR><TR><TD CLASS="l">765</TD><TD>     *      or null if the incoming text is null.</TD></TR><TR><TD CLASS="l">766</TD><TD>     * @throws IOException If the date string is non-null </TD></TR><TR><TD CLASS="l">767</TD><TD>     *      and not a parseable date.</TD></TR><TR><TD CLASS="l">768</TD><TD>     * @deprecated This method throws an IOException for failure. Replace</TD></TR><TR><TD CLASS="l">769</TD><TD>     *      calls to it with {@link #toCalendar(String, String[])}</TD></TR><TR><TD CLASS="l">770</TD><TD>     *      using &lt;pre&gt;null&lt;/pre&gt; for the second parameter</TD></TR><TR><TD CLASS="l">771</TD><TD>     *      and test for failure with</TD></TR><TR><TD CLASS="l"><A NAME="11">772</A></TD><TD>     *          (value == null || value.get(Calendar.YEAR) == INVALID_YEAR)</TD></TR><TR><TD CLASS="l">773</TD><TD>     */</TD></TR><TR><TD CLASS="l">774</TD><TD>    public static Calendar toCalendar(String text) throws IOException</TD></TR><TR><TD CLASS="l">775</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">776</TD><TD>        if (text == null || &#34;&#34;.equals(text))</TD></TR><TR><TD CLASS="l">777</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">778</TD><TD>            return null;    </TD></TR><TR><TD CLASS="l">779</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">780</TD><TD>        Calendar val = toCalendar(text, null);</TD></TR><TR CLASS="c"><TD CLASS="l">781</TD><TD>        if (val != null &amp;&amp; val.get(Calendar.YEAR) == INVALID_YEAR)  </TD></TR><TR><TD CLASS="l">782</TD><TD>        {</TD></TR><TR CLASS="c"><TD CLASS="l">783</TD><TD>            throw new IOException(&#34;Error converting date: &#34; + text);</TD></TR><TR><TD CLASS="l">784</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">785</TD><TD>        return val;</TD></TR><TR><TD CLASS="l">786</TD><TD>    }</TD></TR><TR><TD CLASS="l">787</TD><TD>    </TD></TR><TR><TD CLASS="l">788</TD><TD>    /**</TD></TR><TR><TD CLASS="l">789</TD><TD>     * Converts a string to a calendar. The entire string must be consumed.</TD></TR><TR><TD CLASS="l">790</TD><TD>     * The date must be strictly correct; that is, no field may exceed</TD></TR><TR><TD CLASS="l">791</TD><TD>     * the appropriate limit. Uses {@link #parseDate} to do the actual parsing.</TD></TR><TR><TD CLASS="l">792</TD><TD>     * </TD></TR><TR><TD CLASS="l">793</TD><TD>     * The returned value will have 0 for DST_OFFSET.</TD></TR><TR><TD CLASS="l">794</TD><TD>     * </TD></TR><TR><TD CLASS="l">795</TD><TD>     * @param text The text to parse. Initial spaces and &#34;D:&#34; are skipped over.</TD></TR><TR><TD CLASS="l">796</TD><TD>     * @param moreFmts An Array of formats (as Strings) to try </TD></TR><TR><TD CLASS="l">797</TD><TD>     *      in addition to the standard list.</TD></TR><TR><TD CLASS="l">798</TD><TD>     * @return the Calendar value corresponding to the date text. </TD></TR><TR><TD CLASS="l">799</TD><TD>     *      If text does not represent a valid date, </TD></TR><TR><TD CLASS="l">800</TD><TD>     *      the value is January 1 on year INVALID_YEAR at 0:0:0 GMT.</TD></TR><TR><TD CLASS="l"><A NAME="12">801</A></TD><TD>     * </TD></TR><TR><TD CLASS="l">802</TD><TD>     */</TD></TR><TR><TD CLASS="l">803</TD><TD>    public static Calendar toCalendar(String text, String[] moreFmts)</TD></TR><TR><TD CLASS="l">804</TD><TD>    {</TD></TR><TR CLASS="c"><TD CLASS="l">805</TD><TD>        ParsePosition where = new ParsePosition(0);</TD></TR><TR CLASS="c"><TD CLASS="l">806</TD><TD>        skipOptionals(text, where, &#34; &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">807</TD><TD>        skipString(text, &#34;D:&#34;, where);</TD></TR><TR CLASS="c"><TD CLASS="l">808</TD><TD>        Calendar retCal = parseDate(text, moreFmts, where);   // PARSE THE TEXT</TD></TR><TR CLASS="c"><TD CLASS="l">809</TD><TD>        if (retCal == null || where.getIndex() != text.length()) </TD></TR><TR><TD CLASS="l">810</TD><TD>        {</TD></TR><TR><TD CLASS="l">811</TD><TD>            // the date string is invalid for all formats we tried,</TD></TR><TR CLASS="c"><TD CLASS="l">812</TD><TD>            retCal = newGreg();</TD></TR><TR CLASS="c"><TD CLASS="l">813</TD><TD>            retCal.set(INVALID_YEAR, 0, 1, 0, 0, 0);</TD></TR><TR><TD CLASS="l">814</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">815</TD><TD>        return retCal;</TD></TR><TR><TD CLASS="l">816</TD><TD>    }</TD></TR><TR><TD CLASS="l">817</TD><TD>}</TD></TR></TABLE><P></P><TABLE WIDTH="100%" CLASS="hdft" CELLSPACING="0"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="26.html">org.apache.pdfbox.util</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.1.5320 (stable)</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>